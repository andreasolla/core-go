// Code generated by Thrift Compiler (0.15.0). DO NOT EDIT.

package executor

import (
	"bytes"
	"context"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"ignis/rpc"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

var _ = rpc.GoUnusedProtection__
type IIOModule interface {
  // Parameters:
  //  - Src
  LoadClass(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Path
  LoadLibrary(ctx context.Context, path string) (_err error)
  PartitionCount(ctx context.Context) (_r int64, _err error)
  CountByPartition(ctx context.Context) (_r []int64, _err error)
  PartitionApproxSize(ctx context.Context) (_r int64, _err error)
  // Parameters:
  //  - Path
  //  - Delim
  PlainFile(ctx context.Context, path string, delim int8) (_err error)
  // Parameters:
  //  - Path
  //  - MinPartitions
  //  - Delim
  PlainFile3(ctx context.Context, path string, minPartitions int64, delim int8) (_err error)
  // Parameters:
  //  - Path
  TextFile(ctx context.Context, path string) (_err error)
  // Parameters:
  //  - Path
  //  - MinPartitions
  TextFile2(ctx context.Context, path string, minPartitions int64) (_err error)
  // Parameters:
  //  - Path
  //  - First
  //  - Partitions
  PartitionObjectFile(ctx context.Context, path string, first int64, partitions int64) (_err error)
  // Parameters:
  //  - Path
  //  - First
  //  - Partitions
  //  - Src
  PartitionObjectFile4(ctx context.Context, path string, first int64, partitions int64, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Path
  //  - First
  //  - Partitions
  PartitionTextFile(ctx context.Context, path string, first int64, partitions int64) (_err error)
  // Parameters:
  //  - Path
  //  - First
  //  - Partitions
  //  - ObjectMapping
  PartitionJsonFile4a(ctx context.Context, path string, first int64, partitions int64, objectMapping bool) (_err error)
  // Parameters:
  //  - Path
  //  - First
  //  - Partitions
  //  - Src
  PartitionJsonFile4b(ctx context.Context, path string, first int64, partitions int64, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Path
  //  - Compression
  //  - First
  SaveAsObjectFile(ctx context.Context, path string, compression int8, first int64) (_err error)
  // Parameters:
  //  - Path
  //  - First
  SaveAsTextFile(ctx context.Context, path string, first int64) (_err error)
  // Parameters:
  //  - Path
  //  - First
  //  - Pretty
  SaveAsJsonFile(ctx context.Context, path string, first int64, pretty bool) (_err error)
}

type IIOModuleClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewIIOModuleClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *IIOModuleClient {
  return &IIOModuleClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewIIOModuleClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *IIOModuleClient {
  return &IIOModuleClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewIIOModuleClient(c thrift.TClient) *IIOModuleClient {
  return &IIOModuleClient{
    c: c,
  }
}

func (p *IIOModuleClient) Client_() thrift.TClient {
  return p.c
}

func (p *IIOModuleClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *IIOModuleClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Src
func (p *IIOModuleClient) LoadClass(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args0 IIOModuleLoadClassArgs
  _args0.Src = src
  var _result2 IIOModuleLoadClassResult
  var _meta1 thrift.ResponseMeta
  _meta1, _err = p.Client_().Call(ctx, "loadClass", &_args0, &_result2)
  p.SetLastResponseMeta_(_meta1)
  if _err != nil {
    return
  }
  switch {
  case _result2.Ex!= nil:
    return _result2.Ex
  }

  return nil
}

// Parameters:
//  - Path
func (p *IIOModuleClient) LoadLibrary(ctx context.Context, path string) (_err error) {
  var _args3 IIOModuleLoadLibraryArgs
  _args3.Path = path
  var _result5 IIOModuleLoadLibraryResult
  var _meta4 thrift.ResponseMeta
  _meta4, _err = p.Client_().Call(ctx, "loadLibrary", &_args3, &_result5)
  p.SetLastResponseMeta_(_meta4)
  if _err != nil {
    return
  }
  switch {
  case _result5.Ex!= nil:
    return _result5.Ex
  }

  return nil
}

func (p *IIOModuleClient) PartitionCount(ctx context.Context) (_r int64, _err error) {
  var _args6 IIOModulePartitionCountArgs
  var _result8 IIOModulePartitionCountResult
  var _meta7 thrift.ResponseMeta
  _meta7, _err = p.Client_().Call(ctx, "partitionCount", &_args6, &_result8)
  p.SetLastResponseMeta_(_meta7)
  if _err != nil {
    return
  }
  switch {
  case _result8.Ex!= nil:
    return _r, _result8.Ex
  }

  return _result8.GetSuccess(), nil
}

func (p *IIOModuleClient) CountByPartition(ctx context.Context) (_r []int64, _err error) {
  var _args9 IIOModuleCountByPartitionArgs
  var _result11 IIOModuleCountByPartitionResult
  var _meta10 thrift.ResponseMeta
  _meta10, _err = p.Client_().Call(ctx, "countByPartition", &_args9, &_result11)
  p.SetLastResponseMeta_(_meta10)
  if _err != nil {
    return
  }
  switch {
  case _result11.Ex!= nil:
    return _r, _result11.Ex
  }

  return _result11.GetSuccess(), nil
}

func (p *IIOModuleClient) PartitionApproxSize(ctx context.Context) (_r int64, _err error) {
  var _args12 IIOModulePartitionApproxSizeArgs
  var _result14 IIOModulePartitionApproxSizeResult
  var _meta13 thrift.ResponseMeta
  _meta13, _err = p.Client_().Call(ctx, "partitionApproxSize", &_args12, &_result14)
  p.SetLastResponseMeta_(_meta13)
  if _err != nil {
    return
  }
  switch {
  case _result14.Ex!= nil:
    return _r, _result14.Ex
  }

  return _result14.GetSuccess(), nil
}

// Parameters:
//  - Path
//  - Delim
func (p *IIOModuleClient) PlainFile(ctx context.Context, path string, delim int8) (_err error) {
  var _args15 IIOModulePlainFileArgs
  _args15.Path = path
  _args15.Delim = delim
  var _result17 IIOModulePlainFileResult
  var _meta16 thrift.ResponseMeta
  _meta16, _err = p.Client_().Call(ctx, "plainFile", &_args15, &_result17)
  p.SetLastResponseMeta_(_meta16)
  if _err != nil {
    return
  }
  switch {
  case _result17.Ex!= nil:
    return _result17.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - MinPartitions
//  - Delim
func (p *IIOModuleClient) PlainFile3(ctx context.Context, path string, minPartitions int64, delim int8) (_err error) {
  var _args18 IIOModulePlainFile3Args
  _args18.Path = path
  _args18.MinPartitions = minPartitions
  _args18.Delim = delim
  var _result20 IIOModulePlainFile3Result
  var _meta19 thrift.ResponseMeta
  _meta19, _err = p.Client_().Call(ctx, "plainFile3", &_args18, &_result20)
  p.SetLastResponseMeta_(_meta19)
  if _err != nil {
    return
  }
  switch {
  case _result20.Ex!= nil:
    return _result20.Ex
  }

  return nil
}

// Parameters:
//  - Path
func (p *IIOModuleClient) TextFile(ctx context.Context, path string) (_err error) {
  var _args21 IIOModuleTextFileArgs
  _args21.Path = path
  var _result23 IIOModuleTextFileResult
  var _meta22 thrift.ResponseMeta
  _meta22, _err = p.Client_().Call(ctx, "textFile", &_args21, &_result23)
  p.SetLastResponseMeta_(_meta22)
  if _err != nil {
    return
  }
  switch {
  case _result23.Ex!= nil:
    return _result23.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - MinPartitions
func (p *IIOModuleClient) TextFile2(ctx context.Context, path string, minPartitions int64) (_err error) {
  var _args24 IIOModuleTextFile2Args
  _args24.Path = path
  _args24.MinPartitions = minPartitions
  var _result26 IIOModuleTextFile2Result
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "textFile2", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  switch {
  case _result26.Ex!= nil:
    return _result26.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - First
//  - Partitions
func (p *IIOModuleClient) PartitionObjectFile(ctx context.Context, path string, first int64, partitions int64) (_err error) {
  var _args27 IIOModulePartitionObjectFileArgs
  _args27.Path = path
  _args27.First = first
  _args27.Partitions = partitions
  var _result29 IIOModulePartitionObjectFileResult
  var _meta28 thrift.ResponseMeta
  _meta28, _err = p.Client_().Call(ctx, "partitionObjectFile", &_args27, &_result29)
  p.SetLastResponseMeta_(_meta28)
  if _err != nil {
    return
  }
  switch {
  case _result29.Ex!= nil:
    return _result29.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - First
//  - Partitions
//  - Src
func (p *IIOModuleClient) PartitionObjectFile4(ctx context.Context, path string, first int64, partitions int64, src *rpc.ISource) (_err error) {
  var _args30 IIOModulePartitionObjectFile4Args
  _args30.Path = path
  _args30.First = first
  _args30.Partitions = partitions
  _args30.Src = src
  var _result32 IIOModulePartitionObjectFile4Result
  var _meta31 thrift.ResponseMeta
  _meta31, _err = p.Client_().Call(ctx, "partitionObjectFile4", &_args30, &_result32)
  p.SetLastResponseMeta_(_meta31)
  if _err != nil {
    return
  }
  switch {
  case _result32.Ex!= nil:
    return _result32.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - First
//  - Partitions
func (p *IIOModuleClient) PartitionTextFile(ctx context.Context, path string, first int64, partitions int64) (_err error) {
  var _args33 IIOModulePartitionTextFileArgs
  _args33.Path = path
  _args33.First = first
  _args33.Partitions = partitions
  var _result35 IIOModulePartitionTextFileResult
  var _meta34 thrift.ResponseMeta
  _meta34, _err = p.Client_().Call(ctx, "partitionTextFile", &_args33, &_result35)
  p.SetLastResponseMeta_(_meta34)
  if _err != nil {
    return
  }
  switch {
  case _result35.Ex!= nil:
    return _result35.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - First
//  - Partitions
//  - ObjectMapping
func (p *IIOModuleClient) PartitionJsonFile4a(ctx context.Context, path string, first int64, partitions int64, objectMapping bool) (_err error) {
  var _args36 IIOModulePartitionJsonFile4aArgs
  _args36.Path = path
  _args36.First = first
  _args36.Partitions = partitions
  _args36.ObjectMapping = objectMapping
  var _result38 IIOModulePartitionJsonFile4aResult
  var _meta37 thrift.ResponseMeta
  _meta37, _err = p.Client_().Call(ctx, "partitionJsonFile4a", &_args36, &_result38)
  p.SetLastResponseMeta_(_meta37)
  if _err != nil {
    return
  }
  switch {
  case _result38.Ex!= nil:
    return _result38.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - First
//  - Partitions
//  - Src
func (p *IIOModuleClient) PartitionJsonFile4b(ctx context.Context, path string, first int64, partitions int64, src *rpc.ISource) (_err error) {
  var _args39 IIOModulePartitionJsonFile4bArgs
  _args39.Path = path
  _args39.First = first
  _args39.Partitions = partitions
  _args39.Src = src
  var _result41 IIOModulePartitionJsonFile4bResult
  var _meta40 thrift.ResponseMeta
  _meta40, _err = p.Client_().Call(ctx, "partitionJsonFile4b", &_args39, &_result41)
  p.SetLastResponseMeta_(_meta40)
  if _err != nil {
    return
  }
  switch {
  case _result41.Ex!= nil:
    return _result41.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - Compression
//  - First
func (p *IIOModuleClient) SaveAsObjectFile(ctx context.Context, path string, compression int8, first int64) (_err error) {
  var _args42 IIOModuleSaveAsObjectFileArgs
  _args42.Path = path
  _args42.Compression = compression
  _args42.First = first
  var _result44 IIOModuleSaveAsObjectFileResult
  var _meta43 thrift.ResponseMeta
  _meta43, _err = p.Client_().Call(ctx, "saveAsObjectFile", &_args42, &_result44)
  p.SetLastResponseMeta_(_meta43)
  if _err != nil {
    return
  }
  switch {
  case _result44.Ex!= nil:
    return _result44.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - First
func (p *IIOModuleClient) SaveAsTextFile(ctx context.Context, path string, first int64) (_err error) {
  var _args45 IIOModuleSaveAsTextFileArgs
  _args45.Path = path
  _args45.First = first
  var _result47 IIOModuleSaveAsTextFileResult
  var _meta46 thrift.ResponseMeta
  _meta46, _err = p.Client_().Call(ctx, "saveAsTextFile", &_args45, &_result47)
  p.SetLastResponseMeta_(_meta46)
  if _err != nil {
    return
  }
  switch {
  case _result47.Ex!= nil:
    return _result47.Ex
  }

  return nil
}

// Parameters:
//  - Path
//  - First
//  - Pretty
func (p *IIOModuleClient) SaveAsJsonFile(ctx context.Context, path string, first int64, pretty bool) (_err error) {
  var _args48 IIOModuleSaveAsJsonFileArgs
  _args48.Path = path
  _args48.First = first
  _args48.Pretty = pretty
  var _result50 IIOModuleSaveAsJsonFileResult
  var _meta49 thrift.ResponseMeta
  _meta49, _err = p.Client_().Call(ctx, "saveAsJsonFile", &_args48, &_result50)
  p.SetLastResponseMeta_(_meta49)
  if _err != nil {
    return
  }
  switch {
  case _result50.Ex!= nil:
    return _result50.Ex
  }

  return nil
}

type IIOModuleProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler IIOModule
}

func (p *IIOModuleProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *IIOModuleProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *IIOModuleProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewIIOModuleProcessor(handler IIOModule) *IIOModuleProcessor {

  self51 := &IIOModuleProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self51.processorMap["loadClass"] = &iIOModuleProcessorLoadClass{handler:handler}
  self51.processorMap["loadLibrary"] = &iIOModuleProcessorLoadLibrary{handler:handler}
  self51.processorMap["partitionCount"] = &iIOModuleProcessorPartitionCount{handler:handler}
  self51.processorMap["countByPartition"] = &iIOModuleProcessorCountByPartition{handler:handler}
  self51.processorMap["partitionApproxSize"] = &iIOModuleProcessorPartitionApproxSize{handler:handler}
  self51.processorMap["plainFile"] = &iIOModuleProcessorPlainFile{handler:handler}
  self51.processorMap["plainFile3"] = &iIOModuleProcessorPlainFile3{handler:handler}
  self51.processorMap["textFile"] = &iIOModuleProcessorTextFile{handler:handler}
  self51.processorMap["textFile2"] = &iIOModuleProcessorTextFile2{handler:handler}
  self51.processorMap["partitionObjectFile"] = &iIOModuleProcessorPartitionObjectFile{handler:handler}
  self51.processorMap["partitionObjectFile4"] = &iIOModuleProcessorPartitionObjectFile4{handler:handler}
  self51.processorMap["partitionTextFile"] = &iIOModuleProcessorPartitionTextFile{handler:handler}
  self51.processorMap["partitionJsonFile4a"] = &iIOModuleProcessorPartitionJsonFile4a{handler:handler}
  self51.processorMap["partitionJsonFile4b"] = &iIOModuleProcessorPartitionJsonFile4b{handler:handler}
  self51.processorMap["saveAsObjectFile"] = &iIOModuleProcessorSaveAsObjectFile{handler:handler}
  self51.processorMap["saveAsTextFile"] = &iIOModuleProcessorSaveAsTextFile{handler:handler}
  self51.processorMap["saveAsJsonFile"] = &iIOModuleProcessorSaveAsJsonFile{handler:handler}
return self51
}

func (p *IIOModuleProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x52 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x52.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x52

}

type iIOModuleProcessorLoadClass struct {
  handler IIOModule
}

func (p *iIOModuleProcessorLoadClass) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleLoadClassArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "loadClass", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleLoadClassResult{}
  if err2 = p.handler.LoadClass(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing loadClass: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "loadClass", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "loadClass", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorLoadLibrary struct {
  handler IIOModule
}

func (p *iIOModuleProcessorLoadLibrary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleLoadLibraryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "loadLibrary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleLoadLibraryResult{}
  if err2 = p.handler.LoadLibrary(ctx, args.Path); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing loadLibrary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "loadLibrary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "loadLibrary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPartitionCount struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPartitionCount) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePartitionCountArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionCount", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePartitionCountResult{}
  var retval int64
  if retval, err2 = p.handler.PartitionCount(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing partitionCount: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionCount", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "partitionCount", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorCountByPartition struct {
  handler IIOModule
}

func (p *iIOModuleProcessorCountByPartition) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleCountByPartitionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "countByPartition", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleCountByPartitionResult{}
  var retval []int64
  if retval, err2 = p.handler.CountByPartition(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing countByPartition: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "countByPartition", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "countByPartition", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPartitionApproxSize struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPartitionApproxSize) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePartitionApproxSizeArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionApproxSize", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePartitionApproxSizeResult{}
  var retval int64
  if retval, err2 = p.handler.PartitionApproxSize(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing partitionApproxSize: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionApproxSize", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "partitionApproxSize", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPlainFile struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPlainFile) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePlainFileArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "plainFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePlainFileResult{}
  if err2 = p.handler.PlainFile(ctx, args.Path, args.Delim); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing plainFile: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "plainFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "plainFile", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPlainFile3 struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPlainFile3) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePlainFile3Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "plainFile3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePlainFile3Result{}
  if err2 = p.handler.PlainFile3(ctx, args.Path, args.MinPartitions, args.Delim); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing plainFile3: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "plainFile3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "plainFile3", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorTextFile struct {
  handler IIOModule
}

func (p *iIOModuleProcessorTextFile) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleTextFileArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "textFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleTextFileResult{}
  if err2 = p.handler.TextFile(ctx, args.Path); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing textFile: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "textFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "textFile", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorTextFile2 struct {
  handler IIOModule
}

func (p *iIOModuleProcessorTextFile2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleTextFile2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "textFile2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleTextFile2Result{}
  if err2 = p.handler.TextFile2(ctx, args.Path, args.MinPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing textFile2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "textFile2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "textFile2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPartitionObjectFile struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPartitionObjectFile) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePartitionObjectFileArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionObjectFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePartitionObjectFileResult{}
  if err2 = p.handler.PartitionObjectFile(ctx, args.Path, args.First, args.Partitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing partitionObjectFile: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionObjectFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "partitionObjectFile", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPartitionObjectFile4 struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPartitionObjectFile4) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePartitionObjectFile4Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionObjectFile4", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePartitionObjectFile4Result{}
  if err2 = p.handler.PartitionObjectFile4(ctx, args.Path, args.First, args.Partitions, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing partitionObjectFile4: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionObjectFile4", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "partitionObjectFile4", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPartitionTextFile struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPartitionTextFile) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePartitionTextFileArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionTextFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePartitionTextFileResult{}
  if err2 = p.handler.PartitionTextFile(ctx, args.Path, args.First, args.Partitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing partitionTextFile: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionTextFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "partitionTextFile", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPartitionJsonFile4a struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPartitionJsonFile4a) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePartitionJsonFile4aArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionJsonFile4a", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePartitionJsonFile4aResult{}
  if err2 = p.handler.PartitionJsonFile4a(ctx, args.Path, args.First, args.Partitions, args.ObjectMapping); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing partitionJsonFile4a: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionJsonFile4a", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "partitionJsonFile4a", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorPartitionJsonFile4b struct {
  handler IIOModule
}

func (p *iIOModuleProcessorPartitionJsonFile4b) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModulePartitionJsonFile4bArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionJsonFile4b", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModulePartitionJsonFile4bResult{}
  if err2 = p.handler.PartitionJsonFile4b(ctx, args.Path, args.First, args.Partitions, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing partitionJsonFile4b: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "partitionJsonFile4b", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "partitionJsonFile4b", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorSaveAsObjectFile struct {
  handler IIOModule
}

func (p *iIOModuleProcessorSaveAsObjectFile) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleSaveAsObjectFileArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "saveAsObjectFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleSaveAsObjectFileResult{}
  if err2 = p.handler.SaveAsObjectFile(ctx, args.Path, args.Compression, args.First); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing saveAsObjectFile: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "saveAsObjectFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "saveAsObjectFile", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorSaveAsTextFile struct {
  handler IIOModule
}

func (p *iIOModuleProcessorSaveAsTextFile) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleSaveAsTextFileArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "saveAsTextFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleSaveAsTextFileResult{}
  if err2 = p.handler.SaveAsTextFile(ctx, args.Path, args.First); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing saveAsTextFile: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "saveAsTextFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "saveAsTextFile", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iIOModuleProcessorSaveAsJsonFile struct {
  handler IIOModule
}

func (p *iIOModuleProcessorSaveAsJsonFile) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IIOModuleSaveAsJsonFileArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "saveAsJsonFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IIOModuleSaveAsJsonFileResult{}
  if err2 = p.handler.SaveAsJsonFile(ctx, args.Path, args.First, args.Pretty); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing saveAsJsonFile: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "saveAsJsonFile", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "saveAsJsonFile", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Src
type IIOModuleLoadClassArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIIOModuleLoadClassArgs() *IIOModuleLoadClassArgs {
  return &IIOModuleLoadClassArgs{}
}

var IIOModuleLoadClassArgs_Src_DEFAULT *rpc.ISource
func (p *IIOModuleLoadClassArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IIOModuleLoadClassArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IIOModuleLoadClassArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IIOModuleLoadClassArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleLoadClassArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IIOModuleLoadClassArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loadClass_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleLoadClassArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IIOModuleLoadClassArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleLoadClassArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModuleLoadClassResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleLoadClassResult() *IIOModuleLoadClassResult {
  return &IIOModuleLoadClassResult{}
}

var IIOModuleLoadClassResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleLoadClassResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleLoadClassResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleLoadClassResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleLoadClassResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleLoadClassResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleLoadClassResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loadClass_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleLoadClassResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleLoadClassResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleLoadClassResult(%+v)", *p)
}

// Attributes:
//  - Path
type IIOModuleLoadLibraryArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
}

func NewIIOModuleLoadLibraryArgs() *IIOModuleLoadLibraryArgs {
  return &IIOModuleLoadLibraryArgs{}
}


func (p *IIOModuleLoadLibraryArgs) GetPath() string {
  return p.Path
}
func (p *IIOModuleLoadLibraryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleLoadLibraryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModuleLoadLibraryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loadLibrary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleLoadLibraryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModuleLoadLibraryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleLoadLibraryArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModuleLoadLibraryResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleLoadLibraryResult() *IIOModuleLoadLibraryResult {
  return &IIOModuleLoadLibraryResult{}
}

var IIOModuleLoadLibraryResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleLoadLibraryResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleLoadLibraryResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleLoadLibraryResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleLoadLibraryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleLoadLibraryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleLoadLibraryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "loadLibrary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleLoadLibraryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleLoadLibraryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleLoadLibraryResult(%+v)", *p)
}

type IIOModulePartitionCountArgs struct {
}

func NewIIOModulePartitionCountArgs() *IIOModulePartitionCountArgs {
  return &IIOModulePartitionCountArgs{}
}

func (p *IIOModulePartitionCountArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionCountArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionCount_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionCountArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionCountArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type IIOModulePartitionCountResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePartitionCountResult() *IIOModulePartitionCountResult {
  return &IIOModulePartitionCountResult{}
}

var IIOModulePartitionCountResult_Success_DEFAULT int64
func (p *IIOModulePartitionCountResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return IIOModulePartitionCountResult_Success_DEFAULT
  }
return *p.Success
}
var IIOModulePartitionCountResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePartitionCountResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePartitionCountResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePartitionCountResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IIOModulePartitionCountResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePartitionCountResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionCountResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IIOModulePartitionCountResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePartitionCountResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionCount_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionCountResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionCountResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionCountResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionCountResult(%+v)", *p)
}

type IIOModuleCountByPartitionArgs struct {
}

func NewIIOModuleCountByPartitionArgs() *IIOModuleCountByPartitionArgs {
  return &IIOModuleCountByPartitionArgs{}
}

func (p *IIOModuleCountByPartitionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleCountByPartitionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "countByPartition_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleCountByPartitionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleCountByPartitionArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type IIOModuleCountByPartitionResult struct {
  Success []int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleCountByPartitionResult() *IIOModuleCountByPartitionResult {
  return &IIOModuleCountByPartitionResult{}
}

var IIOModuleCountByPartitionResult_Success_DEFAULT []int64

func (p *IIOModuleCountByPartitionResult) GetSuccess() []int64 {
  return p.Success
}
var IIOModuleCountByPartitionResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleCountByPartitionResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleCountByPartitionResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleCountByPartitionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IIOModuleCountByPartitionResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleCountByPartitionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleCountByPartitionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int64, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem53 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem53 = v
}
    p.Success = append(p.Success, _elem53)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *IIOModuleCountByPartitionResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleCountByPartitionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "countByPartition_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleCountByPartitionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteI64(ctx, int64(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IIOModuleCountByPartitionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleCountByPartitionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleCountByPartitionResult(%+v)", *p)
}

type IIOModulePartitionApproxSizeArgs struct {
}

func NewIIOModulePartitionApproxSizeArgs() *IIOModulePartitionApproxSizeArgs {
  return &IIOModulePartitionApproxSizeArgs{}
}

func (p *IIOModulePartitionApproxSizeArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionApproxSizeArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionApproxSize_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionApproxSizeArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionApproxSizeArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type IIOModulePartitionApproxSizeResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePartitionApproxSizeResult() *IIOModulePartitionApproxSizeResult {
  return &IIOModulePartitionApproxSizeResult{}
}

var IIOModulePartitionApproxSizeResult_Success_DEFAULT int64
func (p *IIOModulePartitionApproxSizeResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return IIOModulePartitionApproxSizeResult_Success_DEFAULT
  }
return *p.Success
}
var IIOModulePartitionApproxSizeResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePartitionApproxSizeResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePartitionApproxSizeResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePartitionApproxSizeResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *IIOModulePartitionApproxSizeResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePartitionApproxSizeResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionApproxSizeResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *IIOModulePartitionApproxSizeResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePartitionApproxSizeResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionApproxSize_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionApproxSizeResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionApproxSizeResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionApproxSizeResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionApproxSizeResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - Delim
type IIOModulePlainFileArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  Delim int8 `thrift:"delim,2" db:"delim" json:"delim"`
}

func NewIIOModulePlainFileArgs() *IIOModulePlainFileArgs {
  return &IIOModulePlainFileArgs{}
}


func (p *IIOModulePlainFileArgs) GetPath() string {
  return p.Path
}

func (p *IIOModulePlainFileArgs) GetDelim() int8 {
  return p.Delim
}
func (p *IIOModulePlainFileArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePlainFileArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModulePlainFileArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := int8(v)
  p.Delim = temp
}
  return nil
}

func (p *IIOModulePlainFileArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "plainFile_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePlainFileArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModulePlainFileArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "delim", thrift.BYTE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:delim: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Delim)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.delim (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:delim: ", p), err) }
  return err
}

func (p *IIOModulePlainFileArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePlainFileArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModulePlainFileResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePlainFileResult() *IIOModulePlainFileResult {
  return &IIOModulePlainFileResult{}
}

var IIOModulePlainFileResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePlainFileResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePlainFileResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePlainFileResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePlainFileResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePlainFileResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePlainFileResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "plainFile_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePlainFileResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePlainFileResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePlainFileResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - MinPartitions
//  - Delim
type IIOModulePlainFile3Args struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  MinPartitions int64 `thrift:"minPartitions,2" db:"minPartitions" json:"minPartitions"`
  Delim int8 `thrift:"delim,3" db:"delim" json:"delim"`
}

func NewIIOModulePlainFile3Args() *IIOModulePlainFile3Args {
  return &IIOModulePlainFile3Args{}
}


func (p *IIOModulePlainFile3Args) GetPath() string {
  return p.Path
}

func (p *IIOModulePlainFile3Args) GetMinPartitions() int64 {
  return p.MinPartitions
}

func (p *IIOModulePlainFile3Args) GetDelim() int8 {
  return p.Delim
}
func (p *IIOModulePlainFile3Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePlainFile3Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModulePlainFile3Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MinPartitions = v
}
  return nil
}

func (p *IIOModulePlainFile3Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := int8(v)
  p.Delim = temp
}
  return nil
}

func (p *IIOModulePlainFile3Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "plainFile3_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePlainFile3Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModulePlainFile3Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:minPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.MinPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:minPartitions: ", p), err) }
  return err
}

func (p *IIOModulePlainFile3Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "delim", thrift.BYTE, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:delim: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Delim)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.delim (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:delim: ", p), err) }
  return err
}

func (p *IIOModulePlainFile3Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePlainFile3Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModulePlainFile3Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePlainFile3Result() *IIOModulePlainFile3Result {
  return &IIOModulePlainFile3Result{}
}

var IIOModulePlainFile3Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePlainFile3Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePlainFile3Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePlainFile3Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePlainFile3Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePlainFile3Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePlainFile3Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "plainFile3_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePlainFile3Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePlainFile3Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePlainFile3Result(%+v)", *p)
}

// Attributes:
//  - Path
type IIOModuleTextFileArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
}

func NewIIOModuleTextFileArgs() *IIOModuleTextFileArgs {
  return &IIOModuleTextFileArgs{}
}


func (p *IIOModuleTextFileArgs) GetPath() string {
  return p.Path
}
func (p *IIOModuleTextFileArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleTextFileArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModuleTextFileArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "textFile_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleTextFileArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModuleTextFileArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleTextFileArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModuleTextFileResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleTextFileResult() *IIOModuleTextFileResult {
  return &IIOModuleTextFileResult{}
}

var IIOModuleTextFileResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleTextFileResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleTextFileResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleTextFileResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleTextFileResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleTextFileResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleTextFileResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "textFile_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleTextFileResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleTextFileResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleTextFileResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - MinPartitions
type IIOModuleTextFile2Args struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  MinPartitions int64 `thrift:"minPartitions,2" db:"minPartitions" json:"minPartitions"`
}

func NewIIOModuleTextFile2Args() *IIOModuleTextFile2Args {
  return &IIOModuleTextFile2Args{}
}


func (p *IIOModuleTextFile2Args) GetPath() string {
  return p.Path
}

func (p *IIOModuleTextFile2Args) GetMinPartitions() int64 {
  return p.MinPartitions
}
func (p *IIOModuleTextFile2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleTextFile2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModuleTextFile2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MinPartitions = v
}
  return nil
}

func (p *IIOModuleTextFile2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "textFile2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleTextFile2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModuleTextFile2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:minPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.MinPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:minPartitions: ", p), err) }
  return err
}

func (p *IIOModuleTextFile2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleTextFile2Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModuleTextFile2Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleTextFile2Result() *IIOModuleTextFile2Result {
  return &IIOModuleTextFile2Result{}
}

var IIOModuleTextFile2Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleTextFile2Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleTextFile2Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleTextFile2Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleTextFile2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleTextFile2Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleTextFile2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "textFile2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleTextFile2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleTextFile2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleTextFile2Result(%+v)", *p)
}

// Attributes:
//  - Path
//  - First
//  - Partitions
type IIOModulePartitionObjectFileArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  First int64 `thrift:"first,2" db:"first" json:"first"`
  Partitions int64 `thrift:"partitions,3" db:"partitions" json:"partitions"`
}

func NewIIOModulePartitionObjectFileArgs() *IIOModulePartitionObjectFileArgs {
  return &IIOModulePartitionObjectFileArgs{}
}


func (p *IIOModulePartitionObjectFileArgs) GetPath() string {
  return p.Path
}

func (p *IIOModulePartitionObjectFileArgs) GetFirst() int64 {
  return p.First
}

func (p *IIOModulePartitionObjectFileArgs) GetPartitions() int64 {
  return p.Partitions
}
func (p *IIOModulePartitionObjectFileArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionObjectFileArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModulePartitionObjectFileArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModulePartitionObjectFileArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *IIOModulePartitionObjectFileArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionObjectFile_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionObjectFileArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModulePartitionObjectFileArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:first: ", p), err) }
  return err
}

func (p *IIOModulePartitionObjectFileArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:partitions: ", p), err) }
  return err
}

func (p *IIOModulePartitionObjectFileArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionObjectFileArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModulePartitionObjectFileResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePartitionObjectFileResult() *IIOModulePartitionObjectFileResult {
  return &IIOModulePartitionObjectFileResult{}
}

var IIOModulePartitionObjectFileResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePartitionObjectFileResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePartitionObjectFileResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePartitionObjectFileResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePartitionObjectFileResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionObjectFileResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePartitionObjectFileResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionObjectFile_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionObjectFileResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionObjectFileResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionObjectFileResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - First
//  - Partitions
//  - Src
type IIOModulePartitionObjectFile4Args struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  First int64 `thrift:"first,2" db:"first" json:"first"`
  Partitions int64 `thrift:"partitions,3" db:"partitions" json:"partitions"`
  Src *rpc.ISource `thrift:"src,4" db:"src" json:"src"`
}

func NewIIOModulePartitionObjectFile4Args() *IIOModulePartitionObjectFile4Args {
  return &IIOModulePartitionObjectFile4Args{}
}


func (p *IIOModulePartitionObjectFile4Args) GetPath() string {
  return p.Path
}

func (p *IIOModulePartitionObjectFile4Args) GetFirst() int64 {
  return p.First
}

func (p *IIOModulePartitionObjectFile4Args) GetPartitions() int64 {
  return p.Partitions
}
var IIOModulePartitionObjectFile4Args_Src_DEFAULT *rpc.ISource
func (p *IIOModulePartitionObjectFile4Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IIOModulePartitionObjectFile4Args_Src_DEFAULT
  }
return p.Src
}
func (p *IIOModulePartitionObjectFile4Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IIOModulePartitionObjectFile4Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionObjectFile4Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModulePartitionObjectFile4Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModulePartitionObjectFile4Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *IIOModulePartitionObjectFile4Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IIOModulePartitionObjectFile4Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionObjectFile4_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionObjectFile4Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModulePartitionObjectFile4Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:first: ", p), err) }
  return err
}

func (p *IIOModulePartitionObjectFile4Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:partitions: ", p), err) }
  return err
}

func (p *IIOModulePartitionObjectFile4Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:src: ", p), err) }
  return err
}

func (p *IIOModulePartitionObjectFile4Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionObjectFile4Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModulePartitionObjectFile4Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePartitionObjectFile4Result() *IIOModulePartitionObjectFile4Result {
  return &IIOModulePartitionObjectFile4Result{}
}

var IIOModulePartitionObjectFile4Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePartitionObjectFile4Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePartitionObjectFile4Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePartitionObjectFile4Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePartitionObjectFile4Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionObjectFile4Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePartitionObjectFile4Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionObjectFile4_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionObjectFile4Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionObjectFile4Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionObjectFile4Result(%+v)", *p)
}

// Attributes:
//  - Path
//  - First
//  - Partitions
type IIOModulePartitionTextFileArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  First int64 `thrift:"first,2" db:"first" json:"first"`
  Partitions int64 `thrift:"partitions,3" db:"partitions" json:"partitions"`
}

func NewIIOModulePartitionTextFileArgs() *IIOModulePartitionTextFileArgs {
  return &IIOModulePartitionTextFileArgs{}
}


func (p *IIOModulePartitionTextFileArgs) GetPath() string {
  return p.Path
}

func (p *IIOModulePartitionTextFileArgs) GetFirst() int64 {
  return p.First
}

func (p *IIOModulePartitionTextFileArgs) GetPartitions() int64 {
  return p.Partitions
}
func (p *IIOModulePartitionTextFileArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionTextFileArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModulePartitionTextFileArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModulePartitionTextFileArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *IIOModulePartitionTextFileArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionTextFile_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionTextFileArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModulePartitionTextFileArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:first: ", p), err) }
  return err
}

func (p *IIOModulePartitionTextFileArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:partitions: ", p), err) }
  return err
}

func (p *IIOModulePartitionTextFileArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionTextFileArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModulePartitionTextFileResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePartitionTextFileResult() *IIOModulePartitionTextFileResult {
  return &IIOModulePartitionTextFileResult{}
}

var IIOModulePartitionTextFileResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePartitionTextFileResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePartitionTextFileResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePartitionTextFileResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePartitionTextFileResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionTextFileResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePartitionTextFileResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionTextFile_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionTextFileResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionTextFileResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionTextFileResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - First
//  - Partitions
//  - ObjectMapping
type IIOModulePartitionJsonFile4aArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  First int64 `thrift:"first,2" db:"first" json:"first"`
  Partitions int64 `thrift:"partitions,3" db:"partitions" json:"partitions"`
  ObjectMapping bool `thrift:"objectMapping,4" db:"objectMapping" json:"objectMapping"`
}

func NewIIOModulePartitionJsonFile4aArgs() *IIOModulePartitionJsonFile4aArgs {
  return &IIOModulePartitionJsonFile4aArgs{}
}


func (p *IIOModulePartitionJsonFile4aArgs) GetPath() string {
  return p.Path
}

func (p *IIOModulePartitionJsonFile4aArgs) GetFirst() int64 {
  return p.First
}

func (p *IIOModulePartitionJsonFile4aArgs) GetPartitions() int64 {
  return p.Partitions
}

func (p *IIOModulePartitionJsonFile4aArgs) GetObjectMapping() bool {
  return p.ObjectMapping
}
func (p *IIOModulePartitionJsonFile4aArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionJsonFile4aArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModulePartitionJsonFile4aArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModulePartitionJsonFile4aArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *IIOModulePartitionJsonFile4aArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ObjectMapping = v
}
  return nil
}

func (p *IIOModulePartitionJsonFile4aArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionJsonFile4a_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionJsonFile4aArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4aArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:first: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4aArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:partitions: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4aArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "objectMapping", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:objectMapping: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.ObjectMapping)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.objectMapping (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:objectMapping: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4aArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionJsonFile4aArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModulePartitionJsonFile4aResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePartitionJsonFile4aResult() *IIOModulePartitionJsonFile4aResult {
  return &IIOModulePartitionJsonFile4aResult{}
}

var IIOModulePartitionJsonFile4aResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePartitionJsonFile4aResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePartitionJsonFile4aResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePartitionJsonFile4aResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePartitionJsonFile4aResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionJsonFile4aResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePartitionJsonFile4aResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionJsonFile4a_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionJsonFile4aResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionJsonFile4aResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionJsonFile4aResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - First
//  - Partitions
//  - Src
type IIOModulePartitionJsonFile4bArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  First int64 `thrift:"first,2" db:"first" json:"first"`
  Partitions int64 `thrift:"partitions,3" db:"partitions" json:"partitions"`
  Src *rpc.ISource `thrift:"src,4" db:"src" json:"src"`
}

func NewIIOModulePartitionJsonFile4bArgs() *IIOModulePartitionJsonFile4bArgs {
  return &IIOModulePartitionJsonFile4bArgs{}
}


func (p *IIOModulePartitionJsonFile4bArgs) GetPath() string {
  return p.Path
}

func (p *IIOModulePartitionJsonFile4bArgs) GetFirst() int64 {
  return p.First
}

func (p *IIOModulePartitionJsonFile4bArgs) GetPartitions() int64 {
  return p.Partitions
}
var IIOModulePartitionJsonFile4bArgs_Src_DEFAULT *rpc.ISource
func (p *IIOModulePartitionJsonFile4bArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IIOModulePartitionJsonFile4bArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IIOModulePartitionJsonFile4bArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IIOModulePartitionJsonFile4bArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionJsonFile4bArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModulePartitionJsonFile4bArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModulePartitionJsonFile4bArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *IIOModulePartitionJsonFile4bArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IIOModulePartitionJsonFile4bArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionJsonFile4b_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionJsonFile4bArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4bArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:first: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4bArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:partitions: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4bArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:src: ", p), err) }
  return err
}

func (p *IIOModulePartitionJsonFile4bArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionJsonFile4bArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModulePartitionJsonFile4bResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModulePartitionJsonFile4bResult() *IIOModulePartitionJsonFile4bResult {
  return &IIOModulePartitionJsonFile4bResult{}
}

var IIOModulePartitionJsonFile4bResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModulePartitionJsonFile4bResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModulePartitionJsonFile4bResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModulePartitionJsonFile4bResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModulePartitionJsonFile4bResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModulePartitionJsonFile4bResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModulePartitionJsonFile4bResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "partitionJsonFile4b_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModulePartitionJsonFile4bResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModulePartitionJsonFile4bResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModulePartitionJsonFile4bResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - Compression
//  - First
type IIOModuleSaveAsObjectFileArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  Compression int8 `thrift:"compression,2" db:"compression" json:"compression"`
  First int64 `thrift:"first,3" db:"first" json:"first"`
}

func NewIIOModuleSaveAsObjectFileArgs() *IIOModuleSaveAsObjectFileArgs {
  return &IIOModuleSaveAsObjectFileArgs{}
}


func (p *IIOModuleSaveAsObjectFileArgs) GetPath() string {
  return p.Path
}

func (p *IIOModuleSaveAsObjectFileArgs) GetCompression() int8 {
  return p.Compression
}

func (p *IIOModuleSaveAsObjectFileArgs) GetFirst() int64 {
  return p.First
}
func (p *IIOModuleSaveAsObjectFileArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleSaveAsObjectFileArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModuleSaveAsObjectFileArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := int8(v)
  p.Compression = temp
}
  return nil
}

func (p *IIOModuleSaveAsObjectFileArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModuleSaveAsObjectFileArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "saveAsObjectFile_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleSaveAsObjectFileArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsObjectFileArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "compression", thrift.BYTE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Compression)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsObjectFileArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:first: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsObjectFileArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleSaveAsObjectFileArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModuleSaveAsObjectFileResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleSaveAsObjectFileResult() *IIOModuleSaveAsObjectFileResult {
  return &IIOModuleSaveAsObjectFileResult{}
}

var IIOModuleSaveAsObjectFileResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleSaveAsObjectFileResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleSaveAsObjectFileResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleSaveAsObjectFileResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleSaveAsObjectFileResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleSaveAsObjectFileResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleSaveAsObjectFileResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "saveAsObjectFile_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleSaveAsObjectFileResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleSaveAsObjectFileResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleSaveAsObjectFileResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - First
type IIOModuleSaveAsTextFileArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  First int64 `thrift:"first,2" db:"first" json:"first"`
}

func NewIIOModuleSaveAsTextFileArgs() *IIOModuleSaveAsTextFileArgs {
  return &IIOModuleSaveAsTextFileArgs{}
}


func (p *IIOModuleSaveAsTextFileArgs) GetPath() string {
  return p.Path
}

func (p *IIOModuleSaveAsTextFileArgs) GetFirst() int64 {
  return p.First
}
func (p *IIOModuleSaveAsTextFileArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleSaveAsTextFileArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModuleSaveAsTextFileArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModuleSaveAsTextFileArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "saveAsTextFile_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleSaveAsTextFileArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsTextFileArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:first: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsTextFileArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleSaveAsTextFileArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModuleSaveAsTextFileResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleSaveAsTextFileResult() *IIOModuleSaveAsTextFileResult {
  return &IIOModuleSaveAsTextFileResult{}
}

var IIOModuleSaveAsTextFileResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleSaveAsTextFileResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleSaveAsTextFileResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleSaveAsTextFileResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleSaveAsTextFileResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleSaveAsTextFileResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleSaveAsTextFileResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "saveAsTextFile_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleSaveAsTextFileResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleSaveAsTextFileResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleSaveAsTextFileResult(%+v)", *p)
}

// Attributes:
//  - Path
//  - First
//  - Pretty
type IIOModuleSaveAsJsonFileArgs struct {
  Path string `thrift:"path,1" db:"path" json:"path"`
  First int64 `thrift:"first,2" db:"first" json:"first"`
  Pretty bool `thrift:"pretty,3" db:"pretty" json:"pretty"`
}

func NewIIOModuleSaveAsJsonFileArgs() *IIOModuleSaveAsJsonFileArgs {
  return &IIOModuleSaveAsJsonFileArgs{}
}


func (p *IIOModuleSaveAsJsonFileArgs) GetPath() string {
  return p.Path
}

func (p *IIOModuleSaveAsJsonFileArgs) GetFirst() int64 {
  return p.First
}

func (p *IIOModuleSaveAsJsonFileArgs) GetPretty() bool {
  return p.Pretty
}
func (p *IIOModuleSaveAsJsonFileArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleSaveAsJsonFileArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Path = v
}
  return nil
}

func (p *IIOModuleSaveAsJsonFileArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *IIOModuleSaveAsJsonFileArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pretty = v
}
  return nil
}

func (p *IIOModuleSaveAsJsonFileArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "saveAsJsonFile_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleSaveAsJsonFileArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "path", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:path: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Path)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.path (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:path: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsJsonFileArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:first: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:first: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsJsonFileArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pretty", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pretty: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Pretty)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pretty (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pretty: ", p), err) }
  return err
}

func (p *IIOModuleSaveAsJsonFileArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleSaveAsJsonFileArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IIOModuleSaveAsJsonFileResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIIOModuleSaveAsJsonFileResult() *IIOModuleSaveAsJsonFileResult {
  return &IIOModuleSaveAsJsonFileResult{}
}

var IIOModuleSaveAsJsonFileResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IIOModuleSaveAsJsonFileResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IIOModuleSaveAsJsonFileResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IIOModuleSaveAsJsonFileResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IIOModuleSaveAsJsonFileResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IIOModuleSaveAsJsonFileResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IIOModuleSaveAsJsonFileResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "saveAsJsonFile_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IIOModuleSaveAsJsonFileResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IIOModuleSaveAsJsonFileResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IIOModuleSaveAsJsonFileResult(%+v)", *p)
}


