// Code generated by Thrift Compiler (0.14.1). DO NOT EDIT.

package executor

import(
	"bytes"
	"context"
	"fmt"
	"time"
	"github.com/apache/thrift/lib/go/thrift"
	"ignis/rpc"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

var _ = rpc.GoUnusedProtection__
type ICommModule interface {
  OpenGroup(ctx context.Context) (_r string, _err error)
  CloseGroup(ctx context.Context) (_err error)
  // Parameters:
  //  - ID
  //  - Leader
  JoinToGroup(ctx context.Context, id string, leader bool) (_err error)
  // Parameters:
  //  - ID
  //  - Leader
  //  - Name
  JoinToGroupName(ctx context.Context, id string, leader bool, name string) (_err error)
  // Parameters:
  //  - Name
  HasGroup(ctx context.Context, name string) (_r bool, _err error)
  // Parameters:
  //  - Name
  DestroyGroup(ctx context.Context, name string) (_err error)
  DestroyGroups(ctx context.Context) (_err error)
  GetProtocol(ctx context.Context) (_r int8, _err error)
  // Parameters:
  //  - Protocol
  GetPartitions(ctx context.Context, protocol int8) (_r [][]byte, _err error)
  // Parameters:
  //  - Protocol
  //  - MinPartitions
  GetPartitions2(ctx context.Context, protocol int8, minPartitions int64) (_r [][]byte, _err error)
  // Parameters:
  //  - Partitions
  SetPartitions(ctx context.Context, partitions [][]byte) (_err error)
  // Parameters:
  //  - Partitions
  //  - Src
  SetPartitions2(ctx context.Context, partitions [][]byte, src *rpc.ISource) (_err error)
  // Parameters:
  //  - N
  NewEmptyPartitions_(ctx context.Context, n int64) (_err error)
  // Parameters:
  //  - N
  //  - Src
  NewEmptyPartitions2_(ctx context.Context, n int64, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  //  - Src
  DriverGather(ctx context.Context, group string, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  //  - Src
  DriverGather0(ctx context.Context, group string, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  //  - Partitions
  DriverScatter(ctx context.Context, group string, partitions int64) (_err error)
  // Parameters:
  //  - Group
  //  - Partitions
  //  - Src
  DriverScatter3(ctx context.Context, group string, partitions int64, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  EnableMultithreading(ctx context.Context, group string) (_r int32, _err error)
  // Parameters:
  //  - Group
  //  - Partition
  //  - Dest
  //  - Thread
  Send(ctx context.Context, group string, partition int64, dest int64, thread int32) (_err error)
  // Parameters:
  //  - Group
  //  - Partition
  //  - Source
  //  - Thread
  Recv(ctx context.Context, group string, partition int64, source int64, thread int32) (_err error)
}

type ICommModuleClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewICommModuleClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ICommModuleClient {
  return &ICommModuleClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewICommModuleClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ICommModuleClient {
  return &ICommModuleClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewICommModuleClient(c thrift.TClient) *ICommModuleClient {
  return &ICommModuleClient{
    c: c,
  }
}

func (p *ICommModuleClient) Client_() thrift.TClient {
  return p.c
}

func (p *ICommModuleClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ICommModuleClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *ICommModuleClient) OpenGroup(ctx context.Context) (_r string, _err error) {
  var _args0 ICommModuleOpenGroupArgs
  var _result2 ICommModuleOpenGroupResult
  var _meta1 thrift.ResponseMeta
  _meta1, _err = p.Client_().Call(ctx, "openGroup", &_args0, &_result2)
  p.SetLastResponseMeta_(_meta1)
  if _err != nil {
    return
  }
  switch {
  case _result2.Ex!= nil:
    return _r, _result2.Ex
  }

  return _result2.GetSuccess(), nil
}

func (p *ICommModuleClient) CloseGroup(ctx context.Context) (_err error) {
  var _args3 ICommModuleCloseGroupArgs
  var _result5 ICommModuleCloseGroupResult
  var _meta4 thrift.ResponseMeta
  _meta4, _err = p.Client_().Call(ctx, "closeGroup", &_args3, &_result5)
  p.SetLastResponseMeta_(_meta4)
  if _err != nil {
    return
  }
  switch {
  case _result5.Ex!= nil:
    return _result5.Ex
  }

  return nil
}

// Parameters:
//  - ID
//  - Leader
func (p *ICommModuleClient) JoinToGroup(ctx context.Context, id string, leader bool) (_err error) {
  var _args6 ICommModuleJoinToGroupArgs
  _args6.ID = id
  _args6.Leader = leader
  var _result8 ICommModuleJoinToGroupResult
  var _meta7 thrift.ResponseMeta
  _meta7, _err = p.Client_().Call(ctx, "joinToGroup", &_args6, &_result8)
  p.SetLastResponseMeta_(_meta7)
  if _err != nil {
    return
  }
  switch {
  case _result8.Ex!= nil:
    return _result8.Ex
  }

  return nil
}

// Parameters:
//  - ID
//  - Leader
//  - Name
func (p *ICommModuleClient) JoinToGroupName(ctx context.Context, id string, leader bool, name string) (_err error) {
  var _args9 ICommModuleJoinToGroupNameArgs
  _args9.ID = id
  _args9.Leader = leader
  _args9.Name = name
  var _result11 ICommModuleJoinToGroupNameResult
  var _meta10 thrift.ResponseMeta
  _meta10, _err = p.Client_().Call(ctx, "joinToGroupName", &_args9, &_result11)
  p.SetLastResponseMeta_(_meta10)
  if _err != nil {
    return
  }
  switch {
  case _result11.Ex!= nil:
    return _result11.Ex
  }

  return nil
}

// Parameters:
//  - Name
func (p *ICommModuleClient) HasGroup(ctx context.Context, name string) (_r bool, _err error) {
  var _args12 ICommModuleHasGroupArgs
  _args12.Name = name
  var _result14 ICommModuleHasGroupResult
  var _meta13 thrift.ResponseMeta
  _meta13, _err = p.Client_().Call(ctx, "hasGroup", &_args12, &_result14)
  p.SetLastResponseMeta_(_meta13)
  if _err != nil {
    return
  }
  switch {
  case _result14.Ex!= nil:
    return _r, _result14.Ex
  }

  return _result14.GetSuccess(), nil
}

// Parameters:
//  - Name
func (p *ICommModuleClient) DestroyGroup(ctx context.Context, name string) (_err error) {
  var _args15 ICommModuleDestroyGroupArgs
  _args15.Name = name
  var _result17 ICommModuleDestroyGroupResult
  var _meta16 thrift.ResponseMeta
  _meta16, _err = p.Client_().Call(ctx, "destroyGroup", &_args15, &_result17)
  p.SetLastResponseMeta_(_meta16)
  if _err != nil {
    return
  }
  switch {
  case _result17.Ex!= nil:
    return _result17.Ex
  }

  return nil
}

func (p *ICommModuleClient) DestroyGroups(ctx context.Context) (_err error) {
  var _args18 ICommModuleDestroyGroupsArgs
  var _result20 ICommModuleDestroyGroupsResult
  var _meta19 thrift.ResponseMeta
  _meta19, _err = p.Client_().Call(ctx, "destroyGroups", &_args18, &_result20)
  p.SetLastResponseMeta_(_meta19)
  if _err != nil {
    return
  }
  switch {
  case _result20.Ex!= nil:
    return _result20.Ex
  }

  return nil
}

func (p *ICommModuleClient) GetProtocol(ctx context.Context) (_r int8, _err error) {
  var _args21 ICommModuleGetProtocolArgs
  var _result23 ICommModuleGetProtocolResult
  var _meta22 thrift.ResponseMeta
  _meta22, _err = p.Client_().Call(ctx, "getProtocol", &_args21, &_result23)
  p.SetLastResponseMeta_(_meta22)
  if _err != nil {
    return
  }
  switch {
  case _result23.Ex!= nil:
    return _r, _result23.Ex
  }

  return _result23.GetSuccess(), nil
}

// Parameters:
//  - Protocol
func (p *ICommModuleClient) GetPartitions(ctx context.Context, protocol int8) (_r [][]byte, _err error) {
  var _args24 ICommModuleGetPartitionsArgs
  _args24.Protocol = protocol
  var _result26 ICommModuleGetPartitionsResult
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "getPartitions", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  switch {
  case _result26.Ex!= nil:
    return _r, _result26.Ex
  }

  return _result26.GetSuccess(), nil
}

// Parameters:
//  - Protocol
//  - MinPartitions
func (p *ICommModuleClient) GetPartitions2(ctx context.Context, protocol int8, minPartitions int64) (_r [][]byte, _err error) {
  var _args27 ICommModuleGetPartitions2Args
  _args27.Protocol = protocol
  _args27.MinPartitions = minPartitions
  var _result29 ICommModuleGetPartitions2Result
  var _meta28 thrift.ResponseMeta
  _meta28, _err = p.Client_().Call(ctx, "getPartitions2", &_args27, &_result29)
  p.SetLastResponseMeta_(_meta28)
  if _err != nil {
    return
  }
  switch {
  case _result29.Ex!= nil:
    return _r, _result29.Ex
  }

  return _result29.GetSuccess(), nil
}

// Parameters:
//  - Partitions
func (p *ICommModuleClient) SetPartitions(ctx context.Context, partitions [][]byte) (_err error) {
  var _args30 ICommModuleSetPartitionsArgs
  _args30.Partitions = partitions
  var _result32 ICommModuleSetPartitionsResult
  var _meta31 thrift.ResponseMeta
  _meta31, _err = p.Client_().Call(ctx, "setPartitions", &_args30, &_result32)
  p.SetLastResponseMeta_(_meta31)
  if _err != nil {
    return
  }
  switch {
  case _result32.Ex!= nil:
    return _result32.Ex
  }

  return nil
}

// Parameters:
//  - Partitions
//  - Src
func (p *ICommModuleClient) SetPartitions2(ctx context.Context, partitions [][]byte, src *rpc.ISource) (_err error) {
  var _args33 ICommModuleSetPartitions2Args
  _args33.Partitions = partitions
  _args33.Src = src
  var _result35 ICommModuleSetPartitions2Result
  var _meta34 thrift.ResponseMeta
  _meta34, _err = p.Client_().Call(ctx, "setPartitions2", &_args33, &_result35)
  p.SetLastResponseMeta_(_meta34)
  if _err != nil {
    return
  }
  switch {
  case _result35.Ex!= nil:
    return _result35.Ex
  }

  return nil
}

// Parameters:
//  - N
func (p *ICommModuleClient) NewEmptyPartitions_(ctx context.Context, n int64) (_err error) {
  var _args36 ICommModuleNewEmptyPartitionsArgs_
  _args36.N = n
  var _result38 ICommModuleNewEmptyPartitionsResult_
  var _meta37 thrift.ResponseMeta
  _meta37, _err = p.Client_().Call(ctx, "newEmptyPartitions", &_args36, &_result38)
  p.SetLastResponseMeta_(_meta37)
  if _err != nil {
    return
  }
  switch {
  case _result38.Ex!= nil:
    return _result38.Ex
  }

  return nil
}

// Parameters:
//  - N
//  - Src
func (p *ICommModuleClient) NewEmptyPartitions2_(ctx context.Context, n int64, src *rpc.ISource) (_err error) {
  var _args39 ICommModuleNewEmptyPartitions2Args_
  _args39.N = n
  _args39.Src = src
  var _result41 ICommModuleNewEmptyPartitions2Result_
  var _meta40 thrift.ResponseMeta
  _meta40, _err = p.Client_().Call(ctx, "newEmptyPartitions2", &_args39, &_result41)
  p.SetLastResponseMeta_(_meta40)
  if _err != nil {
    return
  }
  switch {
  case _result41.Ex!= nil:
    return _result41.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Src
func (p *ICommModuleClient) DriverGather(ctx context.Context, group string, src *rpc.ISource) (_err error) {
  var _args42 ICommModuleDriverGatherArgs
  _args42.Group = group
  _args42.Src = src
  var _result44 ICommModuleDriverGatherResult
  var _meta43 thrift.ResponseMeta
  _meta43, _err = p.Client_().Call(ctx, "driverGather", &_args42, &_result44)
  p.SetLastResponseMeta_(_meta43)
  if _err != nil {
    return
  }
  switch {
  case _result44.Ex!= nil:
    return _result44.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Src
func (p *ICommModuleClient) DriverGather0(ctx context.Context, group string, src *rpc.ISource) (_err error) {
  var _args45 ICommModuleDriverGather0Args
  _args45.Group = group
  _args45.Src = src
  var _result47 ICommModuleDriverGather0Result
  var _meta46 thrift.ResponseMeta
  _meta46, _err = p.Client_().Call(ctx, "driverGather0", &_args45, &_result47)
  p.SetLastResponseMeta_(_meta46)
  if _err != nil {
    return
  }
  switch {
  case _result47.Ex!= nil:
    return _result47.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Partitions
func (p *ICommModuleClient) DriverScatter(ctx context.Context, group string, partitions int64) (_err error) {
  var _args48 ICommModuleDriverScatterArgs
  _args48.Group = group
  _args48.Partitions = partitions
  var _result50 ICommModuleDriverScatterResult
  var _meta49 thrift.ResponseMeta
  _meta49, _err = p.Client_().Call(ctx, "driverScatter", &_args48, &_result50)
  p.SetLastResponseMeta_(_meta49)
  if _err != nil {
    return
  }
  switch {
  case _result50.Ex!= nil:
    return _result50.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Partitions
//  - Src
func (p *ICommModuleClient) DriverScatter3(ctx context.Context, group string, partitions int64, src *rpc.ISource) (_err error) {
  var _args51 ICommModuleDriverScatter3Args
  _args51.Group = group
  _args51.Partitions = partitions
  _args51.Src = src
  var _result53 ICommModuleDriverScatter3Result
  var _meta52 thrift.ResponseMeta
  _meta52, _err = p.Client_().Call(ctx, "driverScatter3", &_args51, &_result53)
  p.SetLastResponseMeta_(_meta52)
  if _err != nil {
    return
  }
  switch {
  case _result53.Ex!= nil:
    return _result53.Ex
  }

  return nil
}

// Parameters:
//  - Group
func (p *ICommModuleClient) EnableMultithreading(ctx context.Context, group string) (_r int32, _err error) {
  var _args54 ICommModuleEnableMultithreadingArgs
  _args54.Group = group
  var _result56 ICommModuleEnableMultithreadingResult
  var _meta55 thrift.ResponseMeta
  _meta55, _err = p.Client_().Call(ctx, "enableMultithreading", &_args54, &_result56)
  p.SetLastResponseMeta_(_meta55)
  if _err != nil {
    return
  }
  switch {
  case _result56.Ex!= nil:
    return _r, _result56.Ex
  }

  return _result56.GetSuccess(), nil
}

// Parameters:
//  - Group
//  - Partition
//  - Dest
//  - Thread
func (p *ICommModuleClient) Send(ctx context.Context, group string, partition int64, dest int64, thread int32) (_err error) {
  var _args57 ICommModuleSendArgs
  _args57.Group = group
  _args57.Partition = partition
  _args57.Dest = dest
  _args57.Thread = thread
  var _result59 ICommModuleSendResult
  var _meta58 thrift.ResponseMeta
  _meta58, _err = p.Client_().Call(ctx, "send", &_args57, &_result59)
  p.SetLastResponseMeta_(_meta58)
  if _err != nil {
    return
  }
  switch {
  case _result59.Ex!= nil:
    return _result59.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Partition
//  - Source
//  - Thread
func (p *ICommModuleClient) Recv(ctx context.Context, group string, partition int64, source int64, thread int32) (_err error) {
  var _args60 ICommModuleRecvArgs
  _args60.Group = group
  _args60.Partition = partition
  _args60.Source = source
  _args60.Thread = thread
  var _result62 ICommModuleRecvResult
  var _meta61 thrift.ResponseMeta
  _meta61, _err = p.Client_().Call(ctx, "recv", &_args60, &_result62)
  p.SetLastResponseMeta_(_meta61)
  if _err != nil {
    return
  }
  switch {
  case _result62.Ex!= nil:
    return _result62.Ex
  }

  return nil
}

type ICommModuleProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler ICommModule
}

func (p *ICommModuleProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ICommModuleProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ICommModuleProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewICommModuleProcessor(handler ICommModule) *ICommModuleProcessor {

  self63 := &ICommModuleProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self63.processorMap["openGroup"] = &iCommModuleProcessorOpenGroup{handler:handler}
  self63.processorMap["closeGroup"] = &iCommModuleProcessorCloseGroup{handler:handler}
  self63.processorMap["joinToGroup"] = &iCommModuleProcessorJoinToGroup{handler:handler}
  self63.processorMap["joinToGroupName"] = &iCommModuleProcessorJoinToGroupName{handler:handler}
  self63.processorMap["hasGroup"] = &iCommModuleProcessorHasGroup{handler:handler}
  self63.processorMap["destroyGroup"] = &iCommModuleProcessorDestroyGroup{handler:handler}
  self63.processorMap["destroyGroups"] = &iCommModuleProcessorDestroyGroups{handler:handler}
  self63.processorMap["getProtocol"] = &iCommModuleProcessorGetProtocol{handler:handler}
  self63.processorMap["getPartitions"] = &iCommModuleProcessorGetPartitions{handler:handler}
  self63.processorMap["getPartitions2"] = &iCommModuleProcessorGetPartitions2{handler:handler}
  self63.processorMap["setPartitions"] = &iCommModuleProcessorSetPartitions{handler:handler}
  self63.processorMap["setPartitions2"] = &iCommModuleProcessorSetPartitions2{handler:handler}
  self63.processorMap["newEmptyPartitions"] = &iCommModuleProcessorNewEmptyPartitions_{handler:handler}
  self63.processorMap["newEmptyPartitions2"] = &iCommModuleProcessorNewEmptyPartitions2_{handler:handler}
  self63.processorMap["driverGather"] = &iCommModuleProcessorDriverGather{handler:handler}
  self63.processorMap["driverGather0"] = &iCommModuleProcessorDriverGather0{handler:handler}
  self63.processorMap["driverScatter"] = &iCommModuleProcessorDriverScatter{handler:handler}
  self63.processorMap["driverScatter3"] = &iCommModuleProcessorDriverScatter3{handler:handler}
  self63.processorMap["enableMultithreading"] = &iCommModuleProcessorEnableMultithreading{handler:handler}
  self63.processorMap["send"] = &iCommModuleProcessorSend{handler:handler}
  self63.processorMap["recv"] = &iCommModuleProcessorRecv{handler:handler}
return self63
}

func (p *ICommModuleProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x64 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x64.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x64

}

type iCommModuleProcessorOpenGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorOpenGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleOpenGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "openGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleOpenGroupResult{}
  var retval string
  if retval, err2 = p.handler.OpenGroup(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "openGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "openGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorCloseGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorCloseGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleCloseGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "closeGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleCloseGroupResult{}
  if err2 = p.handler.CloseGroup(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "closeGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "closeGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorJoinToGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorJoinToGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleJoinToGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleJoinToGroupResult{}
  if err2 = p.handler.JoinToGroup(ctx, args.ID, args.Leader); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing joinToGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "joinToGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorJoinToGroupName struct {
  handler ICommModule
}

func (p *iCommModuleProcessorJoinToGroupName) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleJoinToGroupNameArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroupName", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleJoinToGroupNameResult{}
  if err2 = p.handler.JoinToGroupName(ctx, args.ID, args.Leader, args.Name); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing joinToGroupName: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroupName", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "joinToGroupName", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorHasGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorHasGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleHasGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "hasGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleHasGroupResult{}
  var retval bool
  if retval, err2 = p.handler.HasGroup(ctx, args.Name); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing hasGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "hasGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "hasGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDestroyGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDestroyGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDestroyGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDestroyGroupResult{}
  if err2 = p.handler.DestroyGroup(ctx, args.Name); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing destroyGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "destroyGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDestroyGroups struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDestroyGroups) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDestroyGroupsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroups", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDestroyGroupsResult{}
  if err2 = p.handler.DestroyGroups(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing destroyGroups: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroups", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "destroyGroups", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorGetProtocol struct {
  handler ICommModule
}

func (p *iCommModuleProcessorGetProtocol) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleGetProtocolArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getProtocol", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleGetProtocolResult{}
  var retval int8
  if retval, err2 = p.handler.GetProtocol(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getProtocol: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getProtocol", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getProtocol", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorGetPartitions struct {
  handler ICommModule
}

func (p *iCommModuleProcessorGetPartitions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleGetPartitionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleGetPartitionsResult{}
  var retval [][]byte
  if retval, err2 = p.handler.GetPartitions(ctx, args.Protocol); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPartitions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getPartitions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorGetPartitions2 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorGetPartitions2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleGetPartitions2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleGetPartitions2Result{}
  var retval [][]byte
  if retval, err2 = p.handler.GetPartitions2(ctx, args.Protocol, args.MinPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPartitions2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getPartitions2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorSetPartitions struct {
  handler ICommModule
}

func (p *iCommModuleProcessorSetPartitions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleSetPartitionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleSetPartitionsResult{}
  if err2 = p.handler.SetPartitions(ctx, args.Partitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setPartitions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setPartitions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorSetPartitions2 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorSetPartitions2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleSetPartitions2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleSetPartitions2Result{}
  if err2 = p.handler.SetPartitions2(ctx, args.Partitions, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setPartitions2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setPartitions2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorNewEmptyPartitions_ struct {
  handler ICommModule
}

func (p *iCommModuleProcessorNewEmptyPartitions_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleNewEmptyPartitionsArgs_{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "newEmptyPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleNewEmptyPartitionsResult_{}
  if err2 = p.handler.NewEmptyPartitions_(ctx, args.N); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing newEmptyPartitions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "newEmptyPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "newEmptyPartitions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorNewEmptyPartitions2_ struct {
  handler ICommModule
}

func (p *iCommModuleProcessorNewEmptyPartitions2_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleNewEmptyPartitions2Args_{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "newEmptyPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleNewEmptyPartitions2Result_{}
  if err2 = p.handler.NewEmptyPartitions2_(ctx, args.N, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing newEmptyPartitions2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "newEmptyPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "newEmptyPartitions2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverGather struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverGather) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverGatherArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverGatherResult{}
  if err2 = p.handler.DriverGather(ctx, args.Group, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverGather: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverGather", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverGather0 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverGather0) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverGather0Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather0", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverGather0Result{}
  if err2 = p.handler.DriverGather0(ctx, args.Group, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverGather0: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather0", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverGather0", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverScatter struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverScatter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverScatterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverScatterResult{}
  if err2 = p.handler.DriverScatter(ctx, args.Group, args.Partitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverScatter: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverScatter", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverScatter3 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverScatter3) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverScatter3Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverScatter3Result{}
  if err2 = p.handler.DriverScatter3(ctx, args.Group, args.Partitions, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverScatter3: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverScatter3", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorEnableMultithreading struct {
  handler ICommModule
}

func (p *iCommModuleProcessorEnableMultithreading) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleEnableMultithreadingArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "enableMultithreading", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleEnableMultithreadingResult{}
  var retval int32
  if retval, err2 = p.handler.EnableMultithreading(ctx, args.Group); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableMultithreading: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "enableMultithreading", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "enableMultithreading", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorSend struct {
  handler ICommModule
}

func (p *iCommModuleProcessorSend) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleSendArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "send", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleSendResult{}
  if err2 = p.handler.Send(ctx, args.Group, args.Partition, args.Dest, args.Thread); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing send: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "send", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "send", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorRecv struct {
  handler ICommModule
}

func (p *iCommModuleProcessorRecv) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleRecvArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "recv", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleRecvResult{}
  if err2 = p.handler.Recv(ctx, args.Group, args.Partition, args.Source, args.Thread); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing recv: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "recv", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "recv", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type ICommModuleOpenGroupArgs struct {
}

func NewICommModuleOpenGroupArgs() *ICommModuleOpenGroupArgs {
  return &ICommModuleOpenGroupArgs{}
}

func (p *ICommModuleOpenGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleOpenGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "openGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleOpenGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleOpenGroupArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleOpenGroupResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleOpenGroupResult() *ICommModuleOpenGroupResult {
  return &ICommModuleOpenGroupResult{}
}

var ICommModuleOpenGroupResult_Success_DEFAULT string
func (p *ICommModuleOpenGroupResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return ICommModuleOpenGroupResult_Success_DEFAULT
  }
return *p.Success
}
var ICommModuleOpenGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleOpenGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleOpenGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleOpenGroupResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleOpenGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleOpenGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleOpenGroupResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ICommModuleOpenGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleOpenGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "openGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleOpenGroupResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleOpenGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleOpenGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleOpenGroupResult(%+v)", *p)
}

type ICommModuleCloseGroupArgs struct {
}

func NewICommModuleCloseGroupArgs() *ICommModuleCloseGroupArgs {
  return &ICommModuleCloseGroupArgs{}
}

func (p *ICommModuleCloseGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleCloseGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "closeGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleCloseGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleCloseGroupArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleCloseGroupResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleCloseGroupResult() *ICommModuleCloseGroupResult {
  return &ICommModuleCloseGroupResult{}
}

var ICommModuleCloseGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleCloseGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleCloseGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleCloseGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleCloseGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleCloseGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleCloseGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "closeGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleCloseGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleCloseGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleCloseGroupResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Leader
type ICommModuleJoinToGroupArgs struct {
  ID string `thrift:"id,1" db:"id" json:"id"`
  Leader bool `thrift:"leader,2" db:"leader" json:"leader"`
}

func NewICommModuleJoinToGroupArgs() *ICommModuleJoinToGroupArgs {
  return &ICommModuleJoinToGroupArgs{}
}


func (p *ICommModuleJoinToGroupArgs) GetID() string {
  return p.ID
}

func (p *ICommModuleJoinToGroupArgs) GetLeader() bool {
  return p.Leader
}
func (p *ICommModuleJoinToGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *ICommModuleJoinToGroupArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Leader = v
}
  return nil
}

func (p *ICommModuleJoinToGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "leader", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:leader: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Leader)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.leader (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:leader: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleJoinToGroupResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleJoinToGroupResult() *ICommModuleJoinToGroupResult {
  return &ICommModuleJoinToGroupResult{}
}

var ICommModuleJoinToGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleJoinToGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleJoinToGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleJoinToGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleJoinToGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleJoinToGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Leader
//  - Name
type ICommModuleJoinToGroupNameArgs struct {
  ID string `thrift:"id,1" db:"id" json:"id"`
  Leader bool `thrift:"leader,2" db:"leader" json:"leader"`
  Name string `thrift:"name,3" db:"name" json:"name"`
}

func NewICommModuleJoinToGroupNameArgs() *ICommModuleJoinToGroupNameArgs {
  return &ICommModuleJoinToGroupNameArgs{}
}


func (p *ICommModuleJoinToGroupNameArgs) GetID() string {
  return p.ID
}

func (p *ICommModuleJoinToGroupNameArgs) GetLeader() bool {
  return p.Leader
}

func (p *ICommModuleJoinToGroupNameArgs) GetName() string {
  return p.Name
}
func (p *ICommModuleJoinToGroupNameArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Leader = v
}
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroupName_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupNameArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "leader", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:leader: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Leader)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.leader (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:leader: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupNameArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:name: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupNameArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupNameArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleJoinToGroupNameResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleJoinToGroupNameResult() *ICommModuleJoinToGroupNameResult {
  return &ICommModuleJoinToGroupNameResult{}
}

var ICommModuleJoinToGroupNameResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleJoinToGroupNameResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleJoinToGroupNameResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleJoinToGroupNameResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleJoinToGroupNameResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupNameResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupNameResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroupName_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupNameResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleJoinToGroupNameResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupNameResult(%+v)", *p)
}

// Attributes:
//  - Name
type ICommModuleHasGroupArgs struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewICommModuleHasGroupArgs() *ICommModuleHasGroupArgs {
  return &ICommModuleHasGroupArgs{}
}


func (p *ICommModuleHasGroupArgs) GetName() string {
  return p.Name
}
func (p *ICommModuleHasGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleHasGroupArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ICommModuleHasGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "hasGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleHasGroupArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ICommModuleHasGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleHasGroupArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleHasGroupResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleHasGroupResult() *ICommModuleHasGroupResult {
  return &ICommModuleHasGroupResult{}
}

var ICommModuleHasGroupResult_Success_DEFAULT bool
func (p *ICommModuleHasGroupResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ICommModuleHasGroupResult_Success_DEFAULT
  }
return *p.Success
}
var ICommModuleHasGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleHasGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleHasGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleHasGroupResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleHasGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleHasGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleHasGroupResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ICommModuleHasGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleHasGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "hasGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleHasGroupResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleHasGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleHasGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleHasGroupResult(%+v)", *p)
}

// Attributes:
//  - Name
type ICommModuleDestroyGroupArgs struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewICommModuleDestroyGroupArgs() *ICommModuleDestroyGroupArgs {
  return &ICommModuleDestroyGroupArgs{}
}


func (p *ICommModuleDestroyGroupArgs) GetName() string {
  return p.Name
}
func (p *ICommModuleDestroyGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ICommModuleDestroyGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ICommModuleDestroyGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDestroyGroupResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDestroyGroupResult() *ICommModuleDestroyGroupResult {
  return &ICommModuleDestroyGroupResult{}
}

var ICommModuleDestroyGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDestroyGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDestroyGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDestroyGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDestroyGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDestroyGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupResult(%+v)", *p)
}

type ICommModuleDestroyGroupsArgs struct {
}

func NewICommModuleDestroyGroupsArgs() *ICommModuleDestroyGroupsArgs {
  return &ICommModuleDestroyGroupsArgs{}
}

func (p *ICommModuleDestroyGroupsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroups_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupsArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDestroyGroupsResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDestroyGroupsResult() *ICommModuleDestroyGroupsResult {
  return &ICommModuleDestroyGroupsResult{}
}

var ICommModuleDestroyGroupsResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDestroyGroupsResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDestroyGroupsResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDestroyGroupsResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDestroyGroupsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroups_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDestroyGroupsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupsResult(%+v)", *p)
}

type ICommModuleGetProtocolArgs struct {
}

func NewICommModuleGetProtocolArgs() *ICommModuleGetProtocolArgs {
  return &ICommModuleGetProtocolArgs{}
}

func (p *ICommModuleGetProtocolArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetProtocolArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getProtocol_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetProtocolArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetProtocolArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleGetProtocolResult struct {
  Success *int8 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleGetProtocolResult() *ICommModuleGetProtocolResult {
  return &ICommModuleGetProtocolResult{}
}

var ICommModuleGetProtocolResult_Success_DEFAULT int8
func (p *ICommModuleGetProtocolResult) GetSuccess() int8 {
  if !p.IsSetSuccess() {
    return ICommModuleGetProtocolResult_Success_DEFAULT
  }
return *p.Success
}
var ICommModuleGetProtocolResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleGetProtocolResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleGetProtocolResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleGetProtocolResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleGetProtocolResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleGetProtocolResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetProtocolResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := int8(v)
  p.Success = &temp
}
  return nil
}

func (p *ICommModuleGetProtocolResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleGetProtocolResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getProtocol_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetProtocolResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BYTE, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetProtocolResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetProtocolResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetProtocolResult(%+v)", *p)
}

// Attributes:
//  - Protocol
type ICommModuleGetPartitionsArgs struct {
  Protocol int8 `thrift:"protocol,1" db:"protocol" json:"protocol"`
}

func NewICommModuleGetPartitionsArgs() *ICommModuleGetPartitionsArgs {
  return &ICommModuleGetPartitionsArgs{}
}


func (p *ICommModuleGetPartitionsArgs) GetProtocol() int8 {
  return p.Protocol
}
func (p *ICommModuleGetPartitionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Protocol = temp
}
  return nil
}

func (p *ICommModuleGetPartitionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "protocol", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:protocol: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Protocol)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.protocol (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:protocol: ", p), err) }
  return err
}

func (p *ICommModuleGetPartitionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleGetPartitionsResult struct {
  Success [][]byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleGetPartitionsResult() *ICommModuleGetPartitionsResult {
  return &ICommModuleGetPartitionsResult{}
}

var ICommModuleGetPartitionsResult_Success_DEFAULT [][]byte

func (p *ICommModuleGetPartitionsResult) GetSuccess() [][]byte {
  return p.Success
}
var ICommModuleGetPartitionsResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleGetPartitionsResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleGetPartitionsResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleGetPartitionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleGetPartitionsResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleGetPartitionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem65 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem65 = v
}
    p.Success = append(p.Success, _elem65)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitionsResult(%+v)", *p)
}

// Attributes:
//  - Protocol
//  - MinPartitions
type ICommModuleGetPartitions2Args struct {
  Protocol int8 `thrift:"protocol,1" db:"protocol" json:"protocol"`
  MinPartitions int64 `thrift:"minPartitions,2" db:"minPartitions" json:"minPartitions"`
}

func NewICommModuleGetPartitions2Args() *ICommModuleGetPartitions2Args {
  return &ICommModuleGetPartitions2Args{}
}


func (p *ICommModuleGetPartitions2Args) GetProtocol() int8 {
  return p.Protocol
}

func (p *ICommModuleGetPartitions2Args) GetMinPartitions() int64 {
  return p.MinPartitions
}
func (p *ICommModuleGetPartitions2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Protocol = temp
}
  return nil
}

func (p *ICommModuleGetPartitions2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MinPartitions = v
}
  return nil
}

func (p *ICommModuleGetPartitions2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitions2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "protocol", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:protocol: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Protocol)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.protocol (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:protocol: ", p), err) }
  return err
}

func (p *ICommModuleGetPartitions2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:minPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.MinPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:minPartitions: ", p), err) }
  return err
}

func (p *ICommModuleGetPartitions2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitions2Args(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleGetPartitions2Result struct {
  Success [][]byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleGetPartitions2Result() *ICommModuleGetPartitions2Result {
  return &ICommModuleGetPartitions2Result{}
}

var ICommModuleGetPartitions2Result_Success_DEFAULT [][]byte

func (p *ICommModuleGetPartitions2Result) GetSuccess() [][]byte {
  return p.Success
}
var ICommModuleGetPartitions2Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleGetPartitions2Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleGetPartitions2Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleGetPartitions2Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleGetPartitions2Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleGetPartitions2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem66 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem66 = v
}
    p.Success = append(p.Success, _elem66)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitions2Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitions2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitions2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitions2Result(%+v)", *p)
}

// Attributes:
//  - Partitions
type ICommModuleSetPartitionsArgs struct {
  Partitions [][]byte `thrift:"partitions,1" db:"partitions" json:"partitions"`
}

func NewICommModuleSetPartitionsArgs() *ICommModuleSetPartitionsArgs {
  return &ICommModuleSetPartitionsArgs{}
}


func (p *ICommModuleSetPartitionsArgs) GetPartitions() [][]byte {
  return p.Partitions
}
func (p *ICommModuleSetPartitionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Partitions =  tSlice
  for i := 0; i < size; i ++ {
var _elem67 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem67 = v
}
    p.Partitions = append(p.Partitions, _elem67)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partitions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Partitions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Partitions {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partitions: ", p), err) }
  return err
}

func (p *ICommModuleSetPartitionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitionsArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleSetPartitionsResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleSetPartitionsResult() *ICommModuleSetPartitionsResult {
  return &ICommModuleSetPartitionsResult{}
}

var ICommModuleSetPartitionsResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleSetPartitionsResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleSetPartitionsResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleSetPartitionsResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleSetPartitionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleSetPartitionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitionsResult(%+v)", *p)
}

// Attributes:
//  - Partitions
//  - Src
type ICommModuleSetPartitions2Args struct {
  Partitions [][]byte `thrift:"partitions,1" db:"partitions" json:"partitions"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
}

func NewICommModuleSetPartitions2Args() *ICommModuleSetPartitions2Args {
  return &ICommModuleSetPartitions2Args{}
}


func (p *ICommModuleSetPartitions2Args) GetPartitions() [][]byte {
  return p.Partitions
}
var ICommModuleSetPartitions2Args_Src_DEFAULT *rpc.ISource
func (p *ICommModuleSetPartitions2Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleSetPartitions2Args_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleSetPartitions2Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleSetPartitions2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Partitions =  tSlice
  for i := 0; i < size; i ++ {
var _elem68 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem68 = v
}
    p.Partitions = append(p.Partitions, _elem68)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitions2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partitions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Partitions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Partitions {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partitions: ", p), err) }
  return err
}

func (p *ICommModuleSetPartitions2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *ICommModuleSetPartitions2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitions2Args(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleSetPartitions2Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleSetPartitions2Result() *ICommModuleSetPartitions2Result {
  return &ICommModuleSetPartitions2Result{}
}

var ICommModuleSetPartitions2Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleSetPartitions2Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleSetPartitions2Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleSetPartitions2Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleSetPartitions2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitions2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleSetPartitions2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitions2Result(%+v)", *p)
}

// Attributes:
//  - N
type ICommModuleNewEmptyPartitionsArgs_ struct {
  N int64 `thrift:"n,1" db:"n" json:"n"`
}

func NewICommModuleNewEmptyPartitionsArgs_() *ICommModuleNewEmptyPartitionsArgs_ {
  return &ICommModuleNewEmptyPartitionsArgs_{}
}


func (p *ICommModuleNewEmptyPartitionsArgs_) GetN() int64 {
  return p.N
}
func (p *ICommModuleNewEmptyPartitionsArgs_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleNewEmptyPartitionsArgs_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.N = v
}
  return nil
}

func (p *ICommModuleNewEmptyPartitionsArgs_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "newEmptyPartitions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleNewEmptyPartitionsArgs_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.N)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.n (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ICommModuleNewEmptyPartitionsArgs_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleNewEmptyPartitionsArgs_(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleNewEmptyPartitionsResult_ struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleNewEmptyPartitionsResult_() *ICommModuleNewEmptyPartitionsResult_ {
  return &ICommModuleNewEmptyPartitionsResult_{}
}

var ICommModuleNewEmptyPartitionsResult__Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleNewEmptyPartitionsResult_) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleNewEmptyPartitionsResult__Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleNewEmptyPartitionsResult_) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleNewEmptyPartitionsResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleNewEmptyPartitionsResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleNewEmptyPartitionsResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "newEmptyPartitions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleNewEmptyPartitionsResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleNewEmptyPartitionsResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleNewEmptyPartitionsResult_(%+v)", *p)
}

// Attributes:
//  - N
//  - Src
type ICommModuleNewEmptyPartitions2Args_ struct {
  N int64 `thrift:"n,1" db:"n" json:"n"`
  // unused fields # 2 to 4
  Src *rpc.ISource `thrift:"src,5" db:"src" json:"src"`
}

func NewICommModuleNewEmptyPartitions2Args_() *ICommModuleNewEmptyPartitions2Args_ {
  return &ICommModuleNewEmptyPartitions2Args_{}
}


func (p *ICommModuleNewEmptyPartitions2Args_) GetN() int64 {
  return p.N
}
var ICommModuleNewEmptyPartitions2Args__Src_DEFAULT *rpc.ISource
func (p *ICommModuleNewEmptyPartitions2Args_) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleNewEmptyPartitions2Args__Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleNewEmptyPartitions2Args_) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleNewEmptyPartitions2Args_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleNewEmptyPartitions2Args_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.N = v
}
  return nil
}

func (p *ICommModuleNewEmptyPartitions2Args_)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleNewEmptyPartitions2Args_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "newEmptyPartitions2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleNewEmptyPartitions2Args_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "n", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:n: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.N)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.n (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:n: ", p), err) }
  return err
}

func (p *ICommModuleNewEmptyPartitions2Args_) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:src: ", p), err) }
  return err
}

func (p *ICommModuleNewEmptyPartitions2Args_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleNewEmptyPartitions2Args_(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleNewEmptyPartitions2Result_ struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleNewEmptyPartitions2Result_() *ICommModuleNewEmptyPartitions2Result_ {
  return &ICommModuleNewEmptyPartitions2Result_{}
}

var ICommModuleNewEmptyPartitions2Result__Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleNewEmptyPartitions2Result_) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleNewEmptyPartitions2Result__Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleNewEmptyPartitions2Result_) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleNewEmptyPartitions2Result_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleNewEmptyPartitions2Result_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleNewEmptyPartitions2Result_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "newEmptyPartitions2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleNewEmptyPartitions2Result_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleNewEmptyPartitions2Result_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleNewEmptyPartitions2Result_(%+v)", *p)
}

// Attributes:
//  - Group
//  - Src
type ICommModuleDriverGatherArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
}

func NewICommModuleDriverGatherArgs() *ICommModuleDriverGatherArgs {
  return &ICommModuleDriverGatherArgs{}
}


func (p *ICommModuleDriverGatherArgs) GetGroup() string {
  return p.Group
}
var ICommModuleDriverGatherArgs_Src_DEFAULT *rpc.ISource
func (p *ICommModuleDriverGatherArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleDriverGatherArgs_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleDriverGatherArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleDriverGatherArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverGatherArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGatherArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverGatherArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *ICommModuleDriverGatherArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGatherArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverGatherResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverGatherResult() *ICommModuleDriverGatherResult {
  return &ICommModuleDriverGatherResult{}
}

var ICommModuleDriverGatherResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverGatherResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverGatherResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverGatherResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverGatherResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGatherResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverGatherResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGatherResult(%+v)", *p)
}

// Attributes:
//  - Group
//  - Src
type ICommModuleDriverGather0Args struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
}

func NewICommModuleDriverGather0Args() *ICommModuleDriverGather0Args {
  return &ICommModuleDriverGather0Args{}
}


func (p *ICommModuleDriverGather0Args) GetGroup() string {
  return p.Group
}
var ICommModuleDriverGather0Args_Src_DEFAULT *rpc.ISource
func (p *ICommModuleDriverGather0Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleDriverGather0Args_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleDriverGather0Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleDriverGather0Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverGather0Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather0_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGather0Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverGather0Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *ICommModuleDriverGather0Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGather0Args(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverGather0Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverGather0Result() *ICommModuleDriverGather0Result {
  return &ICommModuleDriverGather0Result{}
}

var ICommModuleDriverGather0Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverGather0Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverGather0Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverGather0Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverGather0Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather0_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGather0Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverGather0Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGather0Result(%+v)", *p)
}

// Attributes:
//  - Group
//  - Partitions
type ICommModuleDriverScatterArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Partitions int64 `thrift:"partitions,2" db:"partitions" json:"partitions"`
}

func NewICommModuleDriverScatterArgs() *ICommModuleDriverScatterArgs {
  return &ICommModuleDriverScatterArgs{}
}


func (p *ICommModuleDriverScatterArgs) GetGroup() string {
  return p.Group
}

func (p *ICommModuleDriverScatterArgs) GetPartitions() int64 {
  return p.Partitions
}
func (p *ICommModuleDriverScatterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverScatterArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *ICommModuleDriverScatterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:partitions: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatterArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverScatterResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverScatterResult() *ICommModuleDriverScatterResult {
  return &ICommModuleDriverScatterResult{}
}

var ICommModuleDriverScatterResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverScatterResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverScatterResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverScatterResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverScatterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverScatterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverScatterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatterResult(%+v)", *p)
}

// Attributes:
//  - Group
//  - Partitions
//  - Src
type ICommModuleDriverScatter3Args struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Partitions int64 `thrift:"partitions,2" db:"partitions" json:"partitions"`
  Src *rpc.ISource `thrift:"src,3" db:"src" json:"src"`
}

func NewICommModuleDriverScatter3Args() *ICommModuleDriverScatter3Args {
  return &ICommModuleDriverScatter3Args{}
}


func (p *ICommModuleDriverScatter3Args) GetGroup() string {
  return p.Group
}

func (p *ICommModuleDriverScatter3Args) GetPartitions() int64 {
  return p.Partitions
}
var ICommModuleDriverScatter3Args_Src_DEFAULT *rpc.ISource
func (p *ICommModuleDriverScatter3Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleDriverScatter3Args_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleDriverScatter3Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleDriverScatter3Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverScatter3Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *ICommModuleDriverScatter3Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter3_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatter3Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatter3Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:partitions: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatter3Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:src: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatter3Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatter3Args(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverScatter3Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverScatter3Result() *ICommModuleDriverScatter3Result {
  return &ICommModuleDriverScatter3Result{}
}

var ICommModuleDriverScatter3Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverScatter3Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverScatter3Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverScatter3Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverScatter3Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter3_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatter3Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverScatter3Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatter3Result(%+v)", *p)
}

// Attributes:
//  - Group
type ICommModuleEnableMultithreadingArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
}

func NewICommModuleEnableMultithreadingArgs() *ICommModuleEnableMultithreadingArgs {
  return &ICommModuleEnableMultithreadingArgs{}
}


func (p *ICommModuleEnableMultithreadingArgs) GetGroup() string {
  return p.Group
}
func (p *ICommModuleEnableMultithreadingArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleEnableMultithreadingArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleEnableMultithreadingArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enableMultithreading_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleEnableMultithreadingArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleEnableMultithreadingArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleEnableMultithreadingArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleEnableMultithreadingResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleEnableMultithreadingResult() *ICommModuleEnableMultithreadingResult {
  return &ICommModuleEnableMultithreadingResult{}
}

var ICommModuleEnableMultithreadingResult_Success_DEFAULT int32
func (p *ICommModuleEnableMultithreadingResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return ICommModuleEnableMultithreadingResult_Success_DEFAULT
  }
return *p.Success
}
var ICommModuleEnableMultithreadingResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleEnableMultithreadingResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleEnableMultithreadingResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleEnableMultithreadingResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleEnableMultithreadingResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleEnableMultithreadingResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleEnableMultithreadingResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ICommModuleEnableMultithreadingResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleEnableMultithreadingResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "enableMultithreading_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleEnableMultithreadingResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleEnableMultithreadingResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleEnableMultithreadingResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleEnableMultithreadingResult(%+v)", *p)
}

// Attributes:
//  - Group
//  - Partition
//  - Dest
//  - Thread
type ICommModuleSendArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Partition int64 `thrift:"partition,2" db:"partition" json:"partition"`
  Dest int64 `thrift:"dest,3" db:"dest" json:"dest"`
  Thread int32 `thrift:"thread,4" db:"thread" json:"thread"`
}

func NewICommModuleSendArgs() *ICommModuleSendArgs {
  return &ICommModuleSendArgs{}
}


func (p *ICommModuleSendArgs) GetGroup() string {
  return p.Group
}

func (p *ICommModuleSendArgs) GetPartition() int64 {
  return p.Partition
}

func (p *ICommModuleSendArgs) GetDest() int64 {
  return p.Dest
}

func (p *ICommModuleSendArgs) GetThread() int32 {
  return p.Thread
}
func (p *ICommModuleSendArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSendArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleSendArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Partition = v
}
  return nil
}

func (p *ICommModuleSendArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Dest = v
}
  return nil
}

func (p *ICommModuleSendArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Thread = v
}
  return nil
}

func (p *ICommModuleSendArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSendArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleSendArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partition", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:partition: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partition (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:partition: ", p), err) }
  return err
}

func (p *ICommModuleSendArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dest", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:dest: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Dest)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dest (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:dest: ", p), err) }
  return err
}

func (p *ICommModuleSendArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "thread", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:thread: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Thread)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.thread (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:thread: ", p), err) }
  return err
}

func (p *ICommModuleSendArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSendArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleSendResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleSendResult() *ICommModuleSendResult {
  return &ICommModuleSendResult{}
}

var ICommModuleSendResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleSendResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleSendResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleSendResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleSendResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSendResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleSendResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "send_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSendResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleSendResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSendResult(%+v)", *p)
}

// Attributes:
//  - Group
//  - Partition
//  - Source
//  - Thread
type ICommModuleRecvArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Partition int64 `thrift:"partition,2" db:"partition" json:"partition"`
  Source int64 `thrift:"source,3" db:"source" json:"source"`
  Thread int32 `thrift:"thread,4" db:"thread" json:"thread"`
}

func NewICommModuleRecvArgs() *ICommModuleRecvArgs {
  return &ICommModuleRecvArgs{}
}


func (p *ICommModuleRecvArgs) GetGroup() string {
  return p.Group
}

func (p *ICommModuleRecvArgs) GetPartition() int64 {
  return p.Partition
}

func (p *ICommModuleRecvArgs) GetSource() int64 {
  return p.Source
}

func (p *ICommModuleRecvArgs) GetThread() int32 {
  return p.Thread
}
func (p *ICommModuleRecvArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleRecvArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleRecvArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Partition = v
}
  return nil
}

func (p *ICommModuleRecvArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Source = v
}
  return nil
}

func (p *ICommModuleRecvArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Thread = v
}
  return nil
}

func (p *ICommModuleRecvArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recv_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleRecvArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleRecvArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partition", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:partition: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partition (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:partition: ", p), err) }
  return err
}

func (p *ICommModuleRecvArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "source", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:source: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Source)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.source (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:source: ", p), err) }
  return err
}

func (p *ICommModuleRecvArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "thread", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:thread: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Thread)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.thread (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:thread: ", p), err) }
  return err
}

func (p *ICommModuleRecvArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleRecvArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleRecvResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleRecvResult() *ICommModuleRecvResult {
  return &ICommModuleRecvResult{}
}

var ICommModuleRecvResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleRecvResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleRecvResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleRecvResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleRecvResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleRecvResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleRecvResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "recv_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleRecvResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleRecvResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleRecvResult(%+v)", *p)
}


