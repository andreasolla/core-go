// Code generated by Thrift Compiler (0.15.0). DO NOT EDIT.

package executor

import (
	"bytes"
	"context"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"ignis/rpc"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

var _ = rpc.GoUnusedProtection__
type ICommModule interface {
  OpenGroup(ctx context.Context) (_r string, _err error)
  CloseGroup(ctx context.Context) (_err error)
  // Parameters:
  //  - ID
  //  - Leader
  JoinToGroup(ctx context.Context, id string, leader bool) (_err error)
  // Parameters:
  //  - ID
  //  - Leader
  //  - Name
  JoinToGroupName(ctx context.Context, id string, leader bool, name string) (_err error)
  // Parameters:
  //  - Name
  HasGroup(ctx context.Context, name string) (_r bool, _err error)
  // Parameters:
  //  - Name
  DestroyGroup(ctx context.Context, name string) (_err error)
  DestroyGroups(ctx context.Context) (_err error)
  GetProtocol(ctx context.Context) (_r int8, _err error)
  // Parameters:
  //  - Protocol
  GetPartitions(ctx context.Context, protocol int8) (_r [][]byte, _err error)
  // Parameters:
  //  - Protocol
  //  - MinPartitions
  GetPartitions2(ctx context.Context, protocol int8, minPartitions int64) (_r [][]byte, _err error)
  // Parameters:
  //  - Partitions
  SetPartitions(ctx context.Context, partitions [][]byte) (_err error)
  // Parameters:
  //  - Partitions
  //  - Src
  SetPartitions2(ctx context.Context, partitions [][]byte, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  //  - Src
  DriverGather(ctx context.Context, group string, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  //  - Src
  DriverGather0(ctx context.Context, group string, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  //  - Partitions
  DriverScatter(ctx context.Context, group string, partitions int64) (_err error)
  // Parameters:
  //  - Group
  //  - Partitions
  //  - Src
  DriverScatter3(ctx context.Context, group string, partitions int64, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Group
  //  - Source
  //  - Threads
  ImportData(ctx context.Context, group string, source bool, threads int64) (_err error)
  // Parameters:
  //  - Group
  //  - Source
  //  - Threads
  //  - Src
  ImportData4(ctx context.Context, group string, source bool, threads int64, src *rpc.ISource) (_err error)
}

type ICommModuleClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewICommModuleClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ICommModuleClient {
  return &ICommModuleClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewICommModuleClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ICommModuleClient {
  return &ICommModuleClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewICommModuleClient(c thrift.TClient) *ICommModuleClient {
  return &ICommModuleClient{
    c: c,
  }
}

func (p *ICommModuleClient) Client_() thrift.TClient {
  return p.c
}

func (p *ICommModuleClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ICommModuleClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

func (p *ICommModuleClient) OpenGroup(ctx context.Context) (_r string, _err error) {
  var _args0 ICommModuleOpenGroupArgs
  var _result2 ICommModuleOpenGroupResult
  var _meta1 thrift.ResponseMeta
  _meta1, _err = p.Client_().Call(ctx, "openGroup", &_args0, &_result2)
  p.SetLastResponseMeta_(_meta1)
  if _err != nil {
    return
  }
  switch {
  case _result2.Ex!= nil:
    return _r, _result2.Ex
  }

  return _result2.GetSuccess(), nil
}

func (p *ICommModuleClient) CloseGroup(ctx context.Context) (_err error) {
  var _args3 ICommModuleCloseGroupArgs
  var _result5 ICommModuleCloseGroupResult
  var _meta4 thrift.ResponseMeta
  _meta4, _err = p.Client_().Call(ctx, "closeGroup", &_args3, &_result5)
  p.SetLastResponseMeta_(_meta4)
  if _err != nil {
    return
  }
  switch {
  case _result5.Ex!= nil:
    return _result5.Ex
  }

  return nil
}

// Parameters:
//  - ID
//  - Leader
func (p *ICommModuleClient) JoinToGroup(ctx context.Context, id string, leader bool) (_err error) {
  var _args6 ICommModuleJoinToGroupArgs
  _args6.ID = id
  _args6.Leader = leader
  var _result8 ICommModuleJoinToGroupResult
  var _meta7 thrift.ResponseMeta
  _meta7, _err = p.Client_().Call(ctx, "joinToGroup", &_args6, &_result8)
  p.SetLastResponseMeta_(_meta7)
  if _err != nil {
    return
  }
  switch {
  case _result8.Ex!= nil:
    return _result8.Ex
  }

  return nil
}

// Parameters:
//  - ID
//  - Leader
//  - Name
func (p *ICommModuleClient) JoinToGroupName(ctx context.Context, id string, leader bool, name string) (_err error) {
  var _args9 ICommModuleJoinToGroupNameArgs
  _args9.ID = id
  _args9.Leader = leader
  _args9.Name = name
  var _result11 ICommModuleJoinToGroupNameResult
  var _meta10 thrift.ResponseMeta
  _meta10, _err = p.Client_().Call(ctx, "joinToGroupName", &_args9, &_result11)
  p.SetLastResponseMeta_(_meta10)
  if _err != nil {
    return
  }
  switch {
  case _result11.Ex!= nil:
    return _result11.Ex
  }

  return nil
}

// Parameters:
//  - Name
func (p *ICommModuleClient) HasGroup(ctx context.Context, name string) (_r bool, _err error) {
  var _args12 ICommModuleHasGroupArgs
  _args12.Name = name
  var _result14 ICommModuleHasGroupResult
  var _meta13 thrift.ResponseMeta
  _meta13, _err = p.Client_().Call(ctx, "hasGroup", &_args12, &_result14)
  p.SetLastResponseMeta_(_meta13)
  if _err != nil {
    return
  }
  switch {
  case _result14.Ex!= nil:
    return _r, _result14.Ex
  }

  return _result14.GetSuccess(), nil
}

// Parameters:
//  - Name
func (p *ICommModuleClient) DestroyGroup(ctx context.Context, name string) (_err error) {
  var _args15 ICommModuleDestroyGroupArgs
  _args15.Name = name
  var _result17 ICommModuleDestroyGroupResult
  var _meta16 thrift.ResponseMeta
  _meta16, _err = p.Client_().Call(ctx, "destroyGroup", &_args15, &_result17)
  p.SetLastResponseMeta_(_meta16)
  if _err != nil {
    return
  }
  switch {
  case _result17.Ex!= nil:
    return _result17.Ex
  }

  return nil
}

func (p *ICommModuleClient) DestroyGroups(ctx context.Context) (_err error) {
  var _args18 ICommModuleDestroyGroupsArgs
  var _result20 ICommModuleDestroyGroupsResult
  var _meta19 thrift.ResponseMeta
  _meta19, _err = p.Client_().Call(ctx, "destroyGroups", &_args18, &_result20)
  p.SetLastResponseMeta_(_meta19)
  if _err != nil {
    return
  }
  switch {
  case _result20.Ex!= nil:
    return _result20.Ex
  }

  return nil
}

func (p *ICommModuleClient) GetProtocol(ctx context.Context) (_r int8, _err error) {
  var _args21 ICommModuleGetProtocolArgs
  var _result23 ICommModuleGetProtocolResult
  var _meta22 thrift.ResponseMeta
  _meta22, _err = p.Client_().Call(ctx, "getProtocol", &_args21, &_result23)
  p.SetLastResponseMeta_(_meta22)
  if _err != nil {
    return
  }
  switch {
  case _result23.Ex!= nil:
    return _r, _result23.Ex
  }

  return _result23.GetSuccess(), nil
}

// Parameters:
//  - Protocol
func (p *ICommModuleClient) GetPartitions(ctx context.Context, protocol int8) (_r [][]byte, _err error) {
  var _args24 ICommModuleGetPartitionsArgs
  _args24.Protocol = protocol
  var _result26 ICommModuleGetPartitionsResult
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "getPartitions", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  switch {
  case _result26.Ex!= nil:
    return _r, _result26.Ex
  }

  return _result26.GetSuccess(), nil
}

// Parameters:
//  - Protocol
//  - MinPartitions
func (p *ICommModuleClient) GetPartitions2(ctx context.Context, protocol int8, minPartitions int64) (_r [][]byte, _err error) {
  var _args27 ICommModuleGetPartitions2Args
  _args27.Protocol = protocol
  _args27.MinPartitions = minPartitions
  var _result29 ICommModuleGetPartitions2Result
  var _meta28 thrift.ResponseMeta
  _meta28, _err = p.Client_().Call(ctx, "getPartitions2", &_args27, &_result29)
  p.SetLastResponseMeta_(_meta28)
  if _err != nil {
    return
  }
  switch {
  case _result29.Ex!= nil:
    return _r, _result29.Ex
  }

  return _result29.GetSuccess(), nil
}

// Parameters:
//  - Partitions
func (p *ICommModuleClient) SetPartitions(ctx context.Context, partitions [][]byte) (_err error) {
  var _args30 ICommModuleSetPartitionsArgs
  _args30.Partitions = partitions
  var _result32 ICommModuleSetPartitionsResult
  var _meta31 thrift.ResponseMeta
  _meta31, _err = p.Client_().Call(ctx, "setPartitions", &_args30, &_result32)
  p.SetLastResponseMeta_(_meta31)
  if _err != nil {
    return
  }
  switch {
  case _result32.Ex!= nil:
    return _result32.Ex
  }

  return nil
}

// Parameters:
//  - Partitions
//  - Src
func (p *ICommModuleClient) SetPartitions2(ctx context.Context, partitions [][]byte, src *rpc.ISource) (_err error) {
  var _args33 ICommModuleSetPartitions2Args
  _args33.Partitions = partitions
  _args33.Src = src
  var _result35 ICommModuleSetPartitions2Result
  var _meta34 thrift.ResponseMeta
  _meta34, _err = p.Client_().Call(ctx, "setPartitions2", &_args33, &_result35)
  p.SetLastResponseMeta_(_meta34)
  if _err != nil {
    return
  }
  switch {
  case _result35.Ex!= nil:
    return _result35.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Src
func (p *ICommModuleClient) DriverGather(ctx context.Context, group string, src *rpc.ISource) (_err error) {
  var _args36 ICommModuleDriverGatherArgs
  _args36.Group = group
  _args36.Src = src
  var _result38 ICommModuleDriverGatherResult
  var _meta37 thrift.ResponseMeta
  _meta37, _err = p.Client_().Call(ctx, "driverGather", &_args36, &_result38)
  p.SetLastResponseMeta_(_meta37)
  if _err != nil {
    return
  }
  switch {
  case _result38.Ex!= nil:
    return _result38.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Src
func (p *ICommModuleClient) DriverGather0(ctx context.Context, group string, src *rpc.ISource) (_err error) {
  var _args39 ICommModuleDriverGather0Args
  _args39.Group = group
  _args39.Src = src
  var _result41 ICommModuleDriverGather0Result
  var _meta40 thrift.ResponseMeta
  _meta40, _err = p.Client_().Call(ctx, "driverGather0", &_args39, &_result41)
  p.SetLastResponseMeta_(_meta40)
  if _err != nil {
    return
  }
  switch {
  case _result41.Ex!= nil:
    return _result41.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Partitions
func (p *ICommModuleClient) DriverScatter(ctx context.Context, group string, partitions int64) (_err error) {
  var _args42 ICommModuleDriverScatterArgs
  _args42.Group = group
  _args42.Partitions = partitions
  var _result44 ICommModuleDriverScatterResult
  var _meta43 thrift.ResponseMeta
  _meta43, _err = p.Client_().Call(ctx, "driverScatter", &_args42, &_result44)
  p.SetLastResponseMeta_(_meta43)
  if _err != nil {
    return
  }
  switch {
  case _result44.Ex!= nil:
    return _result44.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Partitions
//  - Src
func (p *ICommModuleClient) DriverScatter3(ctx context.Context, group string, partitions int64, src *rpc.ISource) (_err error) {
  var _args45 ICommModuleDriverScatter3Args
  _args45.Group = group
  _args45.Partitions = partitions
  _args45.Src = src
  var _result47 ICommModuleDriverScatter3Result
  var _meta46 thrift.ResponseMeta
  _meta46, _err = p.Client_().Call(ctx, "driverScatter3", &_args45, &_result47)
  p.SetLastResponseMeta_(_meta46)
  if _err != nil {
    return
  }
  switch {
  case _result47.Ex!= nil:
    return _result47.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Source
//  - Threads
func (p *ICommModuleClient) ImportData(ctx context.Context, group string, source bool, threads int64) (_err error) {
  var _args48 ICommModuleImportDataArgs
  _args48.Group = group
  _args48.Source = source
  _args48.Threads = threads
  var _result50 ICommModuleImportDataResult
  var _meta49 thrift.ResponseMeta
  _meta49, _err = p.Client_().Call(ctx, "importData", &_args48, &_result50)
  p.SetLastResponseMeta_(_meta49)
  if _err != nil {
    return
  }
  switch {
  case _result50.Ex!= nil:
    return _result50.Ex
  }

  return nil
}

// Parameters:
//  - Group
//  - Source
//  - Threads
//  - Src
func (p *ICommModuleClient) ImportData4(ctx context.Context, group string, source bool, threads int64, src *rpc.ISource) (_err error) {
  var _args51 ICommModuleImportData4Args
  _args51.Group = group
  _args51.Source = source
  _args51.Threads = threads
  _args51.Src = src
  var _result53 ICommModuleImportData4Result
  var _meta52 thrift.ResponseMeta
  _meta52, _err = p.Client_().Call(ctx, "importData4", &_args51, &_result53)
  p.SetLastResponseMeta_(_meta52)
  if _err != nil {
    return
  }
  switch {
  case _result53.Ex!= nil:
    return _result53.Ex
  }

  return nil
}

type ICommModuleProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler ICommModule
}

func (p *ICommModuleProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ICommModuleProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ICommModuleProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewICommModuleProcessor(handler ICommModule) *ICommModuleProcessor {

  self54 := &ICommModuleProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self54.processorMap["openGroup"] = &iCommModuleProcessorOpenGroup{handler:handler}
  self54.processorMap["closeGroup"] = &iCommModuleProcessorCloseGroup{handler:handler}
  self54.processorMap["joinToGroup"] = &iCommModuleProcessorJoinToGroup{handler:handler}
  self54.processorMap["joinToGroupName"] = &iCommModuleProcessorJoinToGroupName{handler:handler}
  self54.processorMap["hasGroup"] = &iCommModuleProcessorHasGroup{handler:handler}
  self54.processorMap["destroyGroup"] = &iCommModuleProcessorDestroyGroup{handler:handler}
  self54.processorMap["destroyGroups"] = &iCommModuleProcessorDestroyGroups{handler:handler}
  self54.processorMap["getProtocol"] = &iCommModuleProcessorGetProtocol{handler:handler}
  self54.processorMap["getPartitions"] = &iCommModuleProcessorGetPartitions{handler:handler}
  self54.processorMap["getPartitions2"] = &iCommModuleProcessorGetPartitions2{handler:handler}
  self54.processorMap["setPartitions"] = &iCommModuleProcessorSetPartitions{handler:handler}
  self54.processorMap["setPartitions2"] = &iCommModuleProcessorSetPartitions2{handler:handler}
  self54.processorMap["driverGather"] = &iCommModuleProcessorDriverGather{handler:handler}
  self54.processorMap["driverGather0"] = &iCommModuleProcessorDriverGather0{handler:handler}
  self54.processorMap["driverScatter"] = &iCommModuleProcessorDriverScatter{handler:handler}
  self54.processorMap["driverScatter3"] = &iCommModuleProcessorDriverScatter3{handler:handler}
  self54.processorMap["importData"] = &iCommModuleProcessorImportData{handler:handler}
  self54.processorMap["importData4"] = &iCommModuleProcessorImportData4{handler:handler}
return self54
}

func (p *ICommModuleProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x55 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x55.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x55

}

type iCommModuleProcessorOpenGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorOpenGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleOpenGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "openGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleOpenGroupResult{}
  var retval string
  if retval, err2 = p.handler.OpenGroup(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "openGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "openGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorCloseGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorCloseGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleCloseGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "closeGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleCloseGroupResult{}
  if err2 = p.handler.CloseGroup(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "closeGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "closeGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorJoinToGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorJoinToGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleJoinToGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleJoinToGroupResult{}
  if err2 = p.handler.JoinToGroup(ctx, args.ID, args.Leader); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing joinToGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "joinToGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorJoinToGroupName struct {
  handler ICommModule
}

func (p *iCommModuleProcessorJoinToGroupName) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleJoinToGroupNameArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroupName", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleJoinToGroupNameResult{}
  if err2 = p.handler.JoinToGroupName(ctx, args.ID, args.Leader, args.Name); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing joinToGroupName: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "joinToGroupName", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "joinToGroupName", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorHasGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorHasGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleHasGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "hasGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleHasGroupResult{}
  var retval bool
  if retval, err2 = p.handler.HasGroup(ctx, args.Name); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing hasGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "hasGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "hasGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDestroyGroup struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDestroyGroup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDestroyGroupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDestroyGroupResult{}
  if err2 = p.handler.DestroyGroup(ctx, args.Name); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing destroyGroup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "destroyGroup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDestroyGroups struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDestroyGroups) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDestroyGroupsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroups", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDestroyGroupsResult{}
  if err2 = p.handler.DestroyGroups(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing destroyGroups: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "destroyGroups", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "destroyGroups", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorGetProtocol struct {
  handler ICommModule
}

func (p *iCommModuleProcessorGetProtocol) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleGetProtocolArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getProtocol", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleGetProtocolResult{}
  var retval int8
  if retval, err2 = p.handler.GetProtocol(ctx); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getProtocol: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getProtocol", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getProtocol", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorGetPartitions struct {
  handler ICommModule
}

func (p *iCommModuleProcessorGetPartitions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleGetPartitionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleGetPartitionsResult{}
  var retval [][]byte
  if retval, err2 = p.handler.GetPartitions(ctx, args.Protocol); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPartitions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getPartitions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorGetPartitions2 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorGetPartitions2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleGetPartitions2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleGetPartitions2Result{}
  var retval [][]byte
  if retval, err2 = p.handler.GetPartitions2(ctx, args.Protocol, args.MinPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPartitions2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getPartitions2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorSetPartitions struct {
  handler ICommModule
}

func (p *iCommModuleProcessorSetPartitions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleSetPartitionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleSetPartitionsResult{}
  if err2 = p.handler.SetPartitions(ctx, args.Partitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setPartitions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setPartitions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorSetPartitions2 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorSetPartitions2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleSetPartitions2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleSetPartitions2Result{}
  if err2 = p.handler.SetPartitions2(ctx, args.Partitions, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setPartitions2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setPartitions2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setPartitions2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverGather struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverGather) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverGatherArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverGatherResult{}
  if err2 = p.handler.DriverGather(ctx, args.Group, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverGather: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverGather", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverGather0 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverGather0) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverGather0Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather0", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverGather0Result{}
  if err2 = p.handler.DriverGather0(ctx, args.Group, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverGather0: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverGather0", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverGather0", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverScatter struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverScatter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverScatterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverScatterResult{}
  if err2 = p.handler.DriverScatter(ctx, args.Group, args.Partitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverScatter: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverScatter", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorDriverScatter3 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorDriverScatter3) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleDriverScatter3Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleDriverScatter3Result{}
  if err2 = p.handler.DriverScatter3(ctx, args.Group, args.Partitions, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing driverScatter3: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "driverScatter3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "driverScatter3", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorImportData struct {
  handler ICommModule
}

func (p *iCommModuleProcessorImportData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleImportDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "importData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleImportDataResult{}
  if err2 = p.handler.ImportData(ctx, args.Group, args.Source, args.Threads); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing importData: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "importData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "importData", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iCommModuleProcessorImportData4 struct {
  handler ICommModule
}

func (p *iCommModuleProcessorImportData4) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ICommModuleImportData4Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "importData4", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ICommModuleImportData4Result{}
  if err2 = p.handler.ImportData4(ctx, args.Group, args.Source, args.Threads, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing importData4: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "importData4", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "importData4", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type ICommModuleOpenGroupArgs struct {
}

func NewICommModuleOpenGroupArgs() *ICommModuleOpenGroupArgs {
  return &ICommModuleOpenGroupArgs{}
}

func (p *ICommModuleOpenGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleOpenGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "openGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleOpenGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleOpenGroupArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleOpenGroupResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleOpenGroupResult() *ICommModuleOpenGroupResult {
  return &ICommModuleOpenGroupResult{}
}

var ICommModuleOpenGroupResult_Success_DEFAULT string
func (p *ICommModuleOpenGroupResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return ICommModuleOpenGroupResult_Success_DEFAULT
  }
return *p.Success
}
var ICommModuleOpenGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleOpenGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleOpenGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleOpenGroupResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleOpenGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleOpenGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleOpenGroupResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ICommModuleOpenGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleOpenGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "openGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleOpenGroupResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleOpenGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleOpenGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleOpenGroupResult(%+v)", *p)
}

type ICommModuleCloseGroupArgs struct {
}

func NewICommModuleCloseGroupArgs() *ICommModuleCloseGroupArgs {
  return &ICommModuleCloseGroupArgs{}
}

func (p *ICommModuleCloseGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleCloseGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "closeGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleCloseGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleCloseGroupArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleCloseGroupResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleCloseGroupResult() *ICommModuleCloseGroupResult {
  return &ICommModuleCloseGroupResult{}
}

var ICommModuleCloseGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleCloseGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleCloseGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleCloseGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleCloseGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleCloseGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleCloseGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "closeGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleCloseGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleCloseGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleCloseGroupResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Leader
type ICommModuleJoinToGroupArgs struct {
  ID string `thrift:"id,1" db:"id" json:"id"`
  Leader bool `thrift:"leader,2" db:"leader" json:"leader"`
}

func NewICommModuleJoinToGroupArgs() *ICommModuleJoinToGroupArgs {
  return &ICommModuleJoinToGroupArgs{}
}


func (p *ICommModuleJoinToGroupArgs) GetID() string {
  return p.ID
}

func (p *ICommModuleJoinToGroupArgs) GetLeader() bool {
  return p.Leader
}
func (p *ICommModuleJoinToGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *ICommModuleJoinToGroupArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Leader = v
}
  return nil
}

func (p *ICommModuleJoinToGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "leader", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:leader: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Leader)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.leader (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:leader: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleJoinToGroupResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleJoinToGroupResult() *ICommModuleJoinToGroupResult {
  return &ICommModuleJoinToGroupResult{}
}

var ICommModuleJoinToGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleJoinToGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleJoinToGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleJoinToGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleJoinToGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleJoinToGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupResult(%+v)", *p)
}

// Attributes:
//  - ID
//  - Leader
//  - Name
type ICommModuleJoinToGroupNameArgs struct {
  ID string `thrift:"id,1" db:"id" json:"id"`
  Leader bool `thrift:"leader,2" db:"leader" json:"leader"`
  Name string `thrift:"name,3" db:"name" json:"name"`
}

func NewICommModuleJoinToGroupNameArgs() *ICommModuleJoinToGroupNameArgs {
  return &ICommModuleJoinToGroupNameArgs{}
}


func (p *ICommModuleJoinToGroupNameArgs) GetID() string {
  return p.ID
}

func (p *ICommModuleJoinToGroupNameArgs) GetLeader() bool {
  return p.Leader
}

func (p *ICommModuleJoinToGroupNameArgs) GetName() string {
  return p.Name
}
func (p *ICommModuleJoinToGroupNameArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Leader = v
}
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroupName_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupNameArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupNameArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "leader", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:leader: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Leader)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.leader (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:leader: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupNameArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:name: ", p), err) }
  return err
}

func (p *ICommModuleJoinToGroupNameArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupNameArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleJoinToGroupNameResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleJoinToGroupNameResult() *ICommModuleJoinToGroupNameResult {
  return &ICommModuleJoinToGroupNameResult{}
}

var ICommModuleJoinToGroupNameResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleJoinToGroupNameResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleJoinToGroupNameResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleJoinToGroupNameResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleJoinToGroupNameResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupNameResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleJoinToGroupNameResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "joinToGroupName_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleJoinToGroupNameResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleJoinToGroupNameResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleJoinToGroupNameResult(%+v)", *p)
}

// Attributes:
//  - Name
type ICommModuleHasGroupArgs struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewICommModuleHasGroupArgs() *ICommModuleHasGroupArgs {
  return &ICommModuleHasGroupArgs{}
}


func (p *ICommModuleHasGroupArgs) GetName() string {
  return p.Name
}
func (p *ICommModuleHasGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleHasGroupArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ICommModuleHasGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "hasGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleHasGroupArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ICommModuleHasGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleHasGroupArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleHasGroupResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleHasGroupResult() *ICommModuleHasGroupResult {
  return &ICommModuleHasGroupResult{}
}

var ICommModuleHasGroupResult_Success_DEFAULT bool
func (p *ICommModuleHasGroupResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return ICommModuleHasGroupResult_Success_DEFAULT
  }
return *p.Success
}
var ICommModuleHasGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleHasGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleHasGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleHasGroupResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleHasGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleHasGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleHasGroupResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ICommModuleHasGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleHasGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "hasGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleHasGroupResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleHasGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleHasGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleHasGroupResult(%+v)", *p)
}

// Attributes:
//  - Name
type ICommModuleDestroyGroupArgs struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewICommModuleDestroyGroupArgs() *ICommModuleDestroyGroupArgs {
  return &ICommModuleDestroyGroupArgs{}
}


func (p *ICommModuleDestroyGroupArgs) GetName() string {
  return p.Name
}
func (p *ICommModuleDestroyGroupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ICommModuleDestroyGroupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ICommModuleDestroyGroupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDestroyGroupResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDestroyGroupResult() *ICommModuleDestroyGroupResult {
  return &ICommModuleDestroyGroupResult{}
}

var ICommModuleDestroyGroupResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDestroyGroupResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDestroyGroupResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDestroyGroupResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDestroyGroupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDestroyGroupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupResult(%+v)", *p)
}

type ICommModuleDestroyGroupsArgs struct {
}

func NewICommModuleDestroyGroupsArgs() *ICommModuleDestroyGroupsArgs {
  return &ICommModuleDestroyGroupsArgs{}
}

func (p *ICommModuleDestroyGroupsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroups_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupsArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDestroyGroupsResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDestroyGroupsResult() *ICommModuleDestroyGroupsResult {
  return &ICommModuleDestroyGroupsResult{}
}

var ICommModuleDestroyGroupsResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDestroyGroupsResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDestroyGroupsResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDestroyGroupsResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDestroyGroupsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDestroyGroupsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "destroyGroups_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDestroyGroupsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDestroyGroupsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDestroyGroupsResult(%+v)", *p)
}

type ICommModuleGetProtocolArgs struct {
}

func NewICommModuleGetProtocolArgs() *ICommModuleGetProtocolArgs {
  return &ICommModuleGetProtocolArgs{}
}

func (p *ICommModuleGetProtocolArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetProtocolArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getProtocol_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetProtocolArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetProtocolArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleGetProtocolResult struct {
  Success *int8 `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleGetProtocolResult() *ICommModuleGetProtocolResult {
  return &ICommModuleGetProtocolResult{}
}

var ICommModuleGetProtocolResult_Success_DEFAULT int8
func (p *ICommModuleGetProtocolResult) GetSuccess() int8 {
  if !p.IsSetSuccess() {
    return ICommModuleGetProtocolResult_Success_DEFAULT
  }
return *p.Success
}
var ICommModuleGetProtocolResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleGetProtocolResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleGetProtocolResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleGetProtocolResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleGetProtocolResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleGetProtocolResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetProtocolResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  temp := int8(v)
  p.Success = &temp
}
  return nil
}

func (p *ICommModuleGetProtocolResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleGetProtocolResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getProtocol_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetProtocolResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BYTE, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetProtocolResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetProtocolResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetProtocolResult(%+v)", *p)
}

// Attributes:
//  - Protocol
type ICommModuleGetPartitionsArgs struct {
  Protocol int8 `thrift:"protocol,1" db:"protocol" json:"protocol"`
}

func NewICommModuleGetPartitionsArgs() *ICommModuleGetPartitionsArgs {
  return &ICommModuleGetPartitionsArgs{}
}


func (p *ICommModuleGetPartitionsArgs) GetProtocol() int8 {
  return p.Protocol
}
func (p *ICommModuleGetPartitionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Protocol = temp
}
  return nil
}

func (p *ICommModuleGetPartitionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "protocol", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:protocol: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Protocol)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.protocol (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:protocol: ", p), err) }
  return err
}

func (p *ICommModuleGetPartitionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleGetPartitionsResult struct {
  Success [][]byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleGetPartitionsResult() *ICommModuleGetPartitionsResult {
  return &ICommModuleGetPartitionsResult{}
}

var ICommModuleGetPartitionsResult_Success_DEFAULT [][]byte

func (p *ICommModuleGetPartitionsResult) GetSuccess() [][]byte {
  return p.Success
}
var ICommModuleGetPartitionsResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleGetPartitionsResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleGetPartitionsResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleGetPartitionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleGetPartitionsResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleGetPartitionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem56 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem56 = v
}
    p.Success = append(p.Success, _elem56)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleGetPartitionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitionsResult(%+v)", *p)
}

// Attributes:
//  - Protocol
//  - MinPartitions
type ICommModuleGetPartitions2Args struct {
  Protocol int8 `thrift:"protocol,1" db:"protocol" json:"protocol"`
  MinPartitions int64 `thrift:"minPartitions,2" db:"minPartitions" json:"minPartitions"`
}

func NewICommModuleGetPartitions2Args() *ICommModuleGetPartitions2Args {
  return &ICommModuleGetPartitions2Args{}
}


func (p *ICommModuleGetPartitions2Args) GetProtocol() int8 {
  return p.Protocol
}

func (p *ICommModuleGetPartitions2Args) GetMinPartitions() int64 {
  return p.MinPartitions
}
func (p *ICommModuleGetPartitions2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Protocol = temp
}
  return nil
}

func (p *ICommModuleGetPartitions2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MinPartitions = v
}
  return nil
}

func (p *ICommModuleGetPartitions2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitions2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "protocol", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:protocol: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Protocol)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.protocol (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:protocol: ", p), err) }
  return err
}

func (p *ICommModuleGetPartitions2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:minPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.MinPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:minPartitions: ", p), err) }
  return err
}

func (p *ICommModuleGetPartitions2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitions2Args(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ex
type ICommModuleGetPartitions2Result struct {
  Success [][]byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleGetPartitions2Result() *ICommModuleGetPartitions2Result {
  return &ICommModuleGetPartitions2Result{}
}

var ICommModuleGetPartitions2Result_Success_DEFAULT [][]byte

func (p *ICommModuleGetPartitions2Result) GetSuccess() [][]byte {
  return p.Success
}
var ICommModuleGetPartitions2Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleGetPartitions2Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleGetPartitions2Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleGetPartitions2Result) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ICommModuleGetPartitions2Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleGetPartitions2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Result)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem57 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem57 = v
}
    p.Success = append(p.Success, _elem57)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleGetPartitions2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPartitions2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleGetPartitions2Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitions2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleGetPartitions2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleGetPartitions2Result(%+v)", *p)
}

// Attributes:
//  - Partitions
type ICommModuleSetPartitionsArgs struct {
  Partitions [][]byte `thrift:"partitions,1" db:"partitions" json:"partitions"`
}

func NewICommModuleSetPartitionsArgs() *ICommModuleSetPartitionsArgs {
  return &ICommModuleSetPartitionsArgs{}
}


func (p *ICommModuleSetPartitionsArgs) GetPartitions() [][]byte {
  return p.Partitions
}
func (p *ICommModuleSetPartitionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Partitions =  tSlice
  for i := 0; i < size; i ++ {
var _elem58 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem58 = v
}
    p.Partitions = append(p.Partitions, _elem58)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partitions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Partitions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Partitions {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partitions: ", p), err) }
  return err
}

func (p *ICommModuleSetPartitionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitionsArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleSetPartitionsResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleSetPartitionsResult() *ICommModuleSetPartitionsResult {
  return &ICommModuleSetPartitionsResult{}
}

var ICommModuleSetPartitionsResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleSetPartitionsResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleSetPartitionsResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleSetPartitionsResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleSetPartitionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleSetPartitionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleSetPartitionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitionsResult(%+v)", *p)
}

// Attributes:
//  - Partitions
//  - Src
type ICommModuleSetPartitions2Args struct {
  Partitions [][]byte `thrift:"partitions,1" db:"partitions" json:"partitions"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
}

func NewICommModuleSetPartitions2Args() *ICommModuleSetPartitions2Args {
  return &ICommModuleSetPartitions2Args{}
}


func (p *ICommModuleSetPartitions2Args) GetPartitions() [][]byte {
  return p.Partitions
}
var ICommModuleSetPartitions2Args_Src_DEFAULT *rpc.ISource
func (p *ICommModuleSetPartitions2Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleSetPartitions2Args_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleSetPartitions2Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleSetPartitions2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Partitions =  tSlice
  for i := 0; i < size; i ++ {
var _elem59 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem59 = v
}
    p.Partitions = append(p.Partitions, _elem59)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitions2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partitions: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Partitions)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Partitions {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partitions: ", p), err) }
  return err
}

func (p *ICommModuleSetPartitions2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *ICommModuleSetPartitions2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitions2Args(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleSetPartitions2Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleSetPartitions2Result() *ICommModuleSetPartitions2Result {
  return &ICommModuleSetPartitions2Result{}
}

var ICommModuleSetPartitions2Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleSetPartitions2Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleSetPartitions2Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleSetPartitions2Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleSetPartitions2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleSetPartitions2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setPartitions2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleSetPartitions2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleSetPartitions2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleSetPartitions2Result(%+v)", *p)
}

// Attributes:
//  - Group
//  - Src
type ICommModuleDriverGatherArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
}

func NewICommModuleDriverGatherArgs() *ICommModuleDriverGatherArgs {
  return &ICommModuleDriverGatherArgs{}
}


func (p *ICommModuleDriverGatherArgs) GetGroup() string {
  return p.Group
}
var ICommModuleDriverGatherArgs_Src_DEFAULT *rpc.ISource
func (p *ICommModuleDriverGatherArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleDriverGatherArgs_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleDriverGatherArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleDriverGatherArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverGatherArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGatherArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverGatherArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *ICommModuleDriverGatherArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGatherArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverGatherResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverGatherResult() *ICommModuleDriverGatherResult {
  return &ICommModuleDriverGatherResult{}
}

var ICommModuleDriverGatherResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverGatherResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverGatherResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverGatherResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverGatherResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverGatherResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGatherResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverGatherResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGatherResult(%+v)", *p)
}

// Attributes:
//  - Group
//  - Src
type ICommModuleDriverGather0Args struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
}

func NewICommModuleDriverGather0Args() *ICommModuleDriverGather0Args {
  return &ICommModuleDriverGather0Args{}
}


func (p *ICommModuleDriverGather0Args) GetGroup() string {
  return p.Group
}
var ICommModuleDriverGather0Args_Src_DEFAULT *rpc.ISource
func (p *ICommModuleDriverGather0Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleDriverGather0Args_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleDriverGather0Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleDriverGather0Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverGather0Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather0_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGather0Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverGather0Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *ICommModuleDriverGather0Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGather0Args(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverGather0Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverGather0Result() *ICommModuleDriverGather0Result {
  return &ICommModuleDriverGather0Result{}
}

var ICommModuleDriverGather0Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverGather0Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverGather0Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverGather0Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverGather0Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverGather0Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverGather0_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverGather0Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverGather0Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverGather0Result(%+v)", *p)
}

// Attributes:
//  - Group
//  - Partitions
type ICommModuleDriverScatterArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Partitions int64 `thrift:"partitions,2" db:"partitions" json:"partitions"`
}

func NewICommModuleDriverScatterArgs() *ICommModuleDriverScatterArgs {
  return &ICommModuleDriverScatterArgs{}
}


func (p *ICommModuleDriverScatterArgs) GetGroup() string {
  return p.Group
}

func (p *ICommModuleDriverScatterArgs) GetPartitions() int64 {
  return p.Partitions
}
func (p *ICommModuleDriverScatterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverScatterArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *ICommModuleDriverScatterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:partitions: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatterArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverScatterResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverScatterResult() *ICommModuleDriverScatterResult {
  return &ICommModuleDriverScatterResult{}
}

var ICommModuleDriverScatterResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverScatterResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverScatterResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverScatterResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverScatterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverScatterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverScatterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatterResult(%+v)", *p)
}

// Attributes:
//  - Group
//  - Partitions
//  - Src
type ICommModuleDriverScatter3Args struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Partitions int64 `thrift:"partitions,2" db:"partitions" json:"partitions"`
  Src *rpc.ISource `thrift:"src,3" db:"src" json:"src"`
}

func NewICommModuleDriverScatter3Args() *ICommModuleDriverScatter3Args {
  return &ICommModuleDriverScatter3Args{}
}


func (p *ICommModuleDriverScatter3Args) GetGroup() string {
  return p.Group
}

func (p *ICommModuleDriverScatter3Args) GetPartitions() int64 {
  return p.Partitions
}
var ICommModuleDriverScatter3Args_Src_DEFAULT *rpc.ISource
func (p *ICommModuleDriverScatter3Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleDriverScatter3Args_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleDriverScatter3Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleDriverScatter3Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleDriverScatter3Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Partitions = v
}
  return nil
}

func (p *ICommModuleDriverScatter3Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter3_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatter3Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatter3Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "partitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:partitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Partitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.partitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:partitions: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatter3Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:src: ", p), err) }
  return err
}

func (p *ICommModuleDriverScatter3Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatter3Args(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleDriverScatter3Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleDriverScatter3Result() *ICommModuleDriverScatter3Result {
  return &ICommModuleDriverScatter3Result{}
}

var ICommModuleDriverScatter3Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleDriverScatter3Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleDriverScatter3Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleDriverScatter3Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleDriverScatter3Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleDriverScatter3Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "driverScatter3_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleDriverScatter3Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleDriverScatter3Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleDriverScatter3Result(%+v)", *p)
}

// Attributes:
//  - Group
//  - Source
//  - Threads
type ICommModuleImportDataArgs struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Source bool `thrift:"source,2" db:"source" json:"source"`
  Threads int64 `thrift:"threads,3" db:"threads" json:"threads"`
}

func NewICommModuleImportDataArgs() *ICommModuleImportDataArgs {
  return &ICommModuleImportDataArgs{}
}


func (p *ICommModuleImportDataArgs) GetGroup() string {
  return p.Group
}

func (p *ICommModuleImportDataArgs) GetSource() bool {
  return p.Source
}

func (p *ICommModuleImportDataArgs) GetThreads() int64 {
  return p.Threads
}
func (p *ICommModuleImportDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleImportDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleImportDataArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Source = v
}
  return nil
}

func (p *ICommModuleImportDataArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Threads = v
}
  return nil
}

func (p *ICommModuleImportDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "importData_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleImportDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleImportDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "source", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:source: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Source)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.source (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:source: ", p), err) }
  return err
}

func (p *ICommModuleImportDataArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "threads", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:threads: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Threads)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.threads (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:threads: ", p), err) }
  return err
}

func (p *ICommModuleImportDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleImportDataArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleImportDataResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleImportDataResult() *ICommModuleImportDataResult {
  return &ICommModuleImportDataResult{}
}

var ICommModuleImportDataResult_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleImportDataResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleImportDataResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleImportDataResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleImportDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleImportDataResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleImportDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "importData_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleImportDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleImportDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleImportDataResult(%+v)", *p)
}

// Attributes:
//  - Group
//  - Source
//  - Threads
//  - Src
type ICommModuleImportData4Args struct {
  Group string `thrift:"group,1" db:"group" json:"group"`
  Source bool `thrift:"source,2" db:"source" json:"source"`
  Threads int64 `thrift:"threads,3" db:"threads" json:"threads"`
  Src *rpc.ISource `thrift:"src,4" db:"src" json:"src"`
}

func NewICommModuleImportData4Args() *ICommModuleImportData4Args {
  return &ICommModuleImportData4Args{}
}


func (p *ICommModuleImportData4Args) GetGroup() string {
  return p.Group
}

func (p *ICommModuleImportData4Args) GetSource() bool {
  return p.Source
}

func (p *ICommModuleImportData4Args) GetThreads() int64 {
  return p.Threads
}
var ICommModuleImportData4Args_Src_DEFAULT *rpc.ISource
func (p *ICommModuleImportData4Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return ICommModuleImportData4Args_Src_DEFAULT
  }
return p.Src
}
func (p *ICommModuleImportData4Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *ICommModuleImportData4Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleImportData4Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Group = v
}
  return nil
}

func (p *ICommModuleImportData4Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Source = v
}
  return nil
}

func (p *ICommModuleImportData4Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Threads = v
}
  return nil
}

func (p *ICommModuleImportData4Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *ICommModuleImportData4Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "importData4_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleImportData4Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "group", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:group: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Group)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.group (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:group: ", p), err) }
  return err
}

func (p *ICommModuleImportData4Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "source", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:source: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Source)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.source (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:source: ", p), err) }
  return err
}

func (p *ICommModuleImportData4Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "threads", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:threads: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Threads)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.threads (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:threads: ", p), err) }
  return err
}

func (p *ICommModuleImportData4Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:src: ", p), err) }
  return err
}

func (p *ICommModuleImportData4Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleImportData4Args(%+v)", *p)
}

// Attributes:
//  - Ex
type ICommModuleImportData4Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewICommModuleImportData4Result() *ICommModuleImportData4Result {
  return &ICommModuleImportData4Result{}
}

var ICommModuleImportData4Result_Ex_DEFAULT *rpc.IExecutorException
func (p *ICommModuleImportData4Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return ICommModuleImportData4Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *ICommModuleImportData4Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *ICommModuleImportData4Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ICommModuleImportData4Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *ICommModuleImportData4Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "importData4_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ICommModuleImportData4Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *ICommModuleImportData4Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ICommModuleImportData4Result(%+v)", *p)
}


