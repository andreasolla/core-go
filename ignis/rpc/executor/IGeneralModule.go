// Code generated by Thrift Compiler (0.14.1). DO NOT EDIT.

package executor

import(
	"bytes"
	"context"
	"fmt"
	"time"
	"github.com/apache/thrift/lib/go/thrift"
	"ignis/rpc"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

var _ = rpc.GoUnusedProtection__
type IGeneralModule interface {
  // Parameters:
  //  - Src
  ExecuteTo(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  Map_(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  Filter(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  Flatmap(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  KeyBy(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  MapPartitions(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  //  - PreservesPartitioning
  MapPartitionsWithIndex(ctx context.Context, src *rpc.ISource, preservesPartitioning bool) (_err error)
  // Parameters:
  //  - Src
  MapExecutor(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  MapExecutorTo(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  //  - NumPartitions
  GroupBy(ctx context.Context, src *rpc.ISource, numPartitions int64) (_err error)
  // Parameters:
  //  - Ascending
  Sort(ctx context.Context, ascending bool) (_err error)
  // Parameters:
  //  - Ascending
  //  - NumPartitions
  Sort2(ctx context.Context, ascending bool, numPartitions int64) (_err error)
  // Parameters:
  //  - Src
  //  - Ascending
  SortBy(ctx context.Context, src *rpc.ISource, ascending bool) (_err error)
  // Parameters:
  //  - Src
  //  - Ascending
  //  - NumPartitions
  SortBy3(ctx context.Context, src *rpc.ISource, ascending bool, numPartitions int64) (_err error)
  // Parameters:
  //  - Src
  FlatMapValues(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  MapValues(ctx context.Context, src *rpc.ISource) (_err error)
  // Parameters:
  //  - NumPartitions
  GroupByKey(ctx context.Context, numPartitions int64) (_err error)
  // Parameters:
  //  - NumPartitions
  //  - Src
  GroupByKey2(ctx context.Context, numPartitions int64, src *rpc.ISource) (_err error)
  // Parameters:
  //  - Src
  //  - NumPartitions
  //  - LocalReduce
  ReduceByKey(ctx context.Context, src *rpc.ISource, numPartitions int64, localReduce bool) (_err error)
  // Parameters:
  //  - Zero
  //  - SeqOp
  //  - NumPartitions
  AggregateByKey(ctx context.Context, zero *rpc.ISource, seqOp *rpc.ISource, numPartitions int64) (_err error)
  // Parameters:
  //  - Zero
  //  - SeqOp
  //  - CombOp
  //  - NumPartitions
  AggregateByKey4(ctx context.Context, zero *rpc.ISource, seqOp *rpc.ISource, combOp *rpc.ISource, numPartitions int64) (_err error)
  // Parameters:
  //  - Zero
  //  - Src
  //  - NumPartitions
  //  - LocalFold
  FoldByKey(ctx context.Context, zero *rpc.ISource, src *rpc.ISource, numPartitions int64, localFold bool) (_err error)
  // Parameters:
  //  - Ascending
  SortByKey(ctx context.Context, ascending bool) (_err error)
  // Parameters:
  //  - Ascending
  //  - NumPartitions
  SortByKey2a(ctx context.Context, ascending bool, numPartitions int64) (_err error)
  // Parameters:
  //  - Src
  //  - Ascending
  SortByKey2b(ctx context.Context, src *rpc.ISource, ascending bool) (_err error)
  // Parameters:
  //  - Src
  //  - Ascending
  //  - NumPartitions
  SortByKey3(ctx context.Context, src *rpc.ISource, ascending bool, numPartitions int64) (_err error)
}

type IGeneralModuleClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewIGeneralModuleClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *IGeneralModuleClient {
  return &IGeneralModuleClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewIGeneralModuleClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *IGeneralModuleClient {
  return &IGeneralModuleClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewIGeneralModuleClient(c thrift.TClient) *IGeneralModuleClient {
  return &IGeneralModuleClient{
    c: c,
  }
}

func (p *IGeneralModuleClient) Client_() thrift.TClient {
  return p.c
}

func (p *IGeneralModuleClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *IGeneralModuleClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) ExecuteTo(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args0 IGeneralModuleExecuteToArgs
  _args0.Src = src
  var _result2 IGeneralModuleExecuteToResult
  var _meta1 thrift.ResponseMeta
  _meta1, _err = p.Client_().Call(ctx, "executeTo", &_args0, &_result2)
  p.SetLastResponseMeta_(_meta1)
  if _err != nil {
    return
  }
  switch {
  case _result2.Ex!= nil:
    return _result2.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) Map_(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args3 IGeneralModuleMap_Args
  _args3.Src = src
  var _result5 IGeneralModuleMap_Result
  var _meta4 thrift.ResponseMeta
  _meta4, _err = p.Client_().Call(ctx, "map_", &_args3, &_result5)
  p.SetLastResponseMeta_(_meta4)
  if _err != nil {
    return
  }
  switch {
  case _result5.Ex!= nil:
    return _result5.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) Filter(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args6 IGeneralModuleFilterArgs
  _args6.Src = src
  var _result8 IGeneralModuleFilterResult
  var _meta7 thrift.ResponseMeta
  _meta7, _err = p.Client_().Call(ctx, "filter", &_args6, &_result8)
  p.SetLastResponseMeta_(_meta7)
  if _err != nil {
    return
  }
  switch {
  case _result8.Ex!= nil:
    return _result8.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) Flatmap(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args9 IGeneralModuleFlatmapArgs
  _args9.Src = src
  var _result11 IGeneralModuleFlatmapResult
  var _meta10 thrift.ResponseMeta
  _meta10, _err = p.Client_().Call(ctx, "flatmap", &_args9, &_result11)
  p.SetLastResponseMeta_(_meta10)
  if _err != nil {
    return
  }
  switch {
  case _result11.Ex!= nil:
    return _result11.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) KeyBy(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args12 IGeneralModuleKeyByArgs
  _args12.Src = src
  var _result14 IGeneralModuleKeyByResult
  var _meta13 thrift.ResponseMeta
  _meta13, _err = p.Client_().Call(ctx, "keyBy", &_args12, &_result14)
  p.SetLastResponseMeta_(_meta13)
  if _err != nil {
    return
  }
  switch {
  case _result14.Ex!= nil:
    return _result14.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) MapPartitions(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args15 IGeneralModuleMapPartitionsArgs
  _args15.Src = src
  var _result17 IGeneralModuleMapPartitionsResult
  var _meta16 thrift.ResponseMeta
  _meta16, _err = p.Client_().Call(ctx, "mapPartitions", &_args15, &_result17)
  p.SetLastResponseMeta_(_meta16)
  if _err != nil {
    return
  }
  switch {
  case _result17.Ex!= nil:
    return _result17.Ex
  }

  return nil
}

// Parameters:
//  - Src
//  - PreservesPartitioning
func (p *IGeneralModuleClient) MapPartitionsWithIndex(ctx context.Context, src *rpc.ISource, preservesPartitioning bool) (_err error) {
  var _args18 IGeneralModuleMapPartitionsWithIndexArgs
  _args18.Src = src
  _args18.PreservesPartitioning = preservesPartitioning
  var _result20 IGeneralModuleMapPartitionsWithIndexResult
  var _meta19 thrift.ResponseMeta
  _meta19, _err = p.Client_().Call(ctx, "mapPartitionsWithIndex", &_args18, &_result20)
  p.SetLastResponseMeta_(_meta19)
  if _err != nil {
    return
  }
  switch {
  case _result20.Ex!= nil:
    return _result20.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) MapExecutor(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args21 IGeneralModuleMapExecutorArgs
  _args21.Src = src
  var _result23 IGeneralModuleMapExecutorResult
  var _meta22 thrift.ResponseMeta
  _meta22, _err = p.Client_().Call(ctx, "mapExecutor", &_args21, &_result23)
  p.SetLastResponseMeta_(_meta22)
  if _err != nil {
    return
  }
  switch {
  case _result23.Ex!= nil:
    return _result23.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) MapExecutorTo(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args24 IGeneralModuleMapExecutorToArgs
  _args24.Src = src
  var _result26 IGeneralModuleMapExecutorToResult
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "mapExecutorTo", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  switch {
  case _result26.Ex!= nil:
    return _result26.Ex
  }

  return nil
}

// Parameters:
//  - Src
//  - NumPartitions
func (p *IGeneralModuleClient) GroupBy(ctx context.Context, src *rpc.ISource, numPartitions int64) (_err error) {
  var _args27 IGeneralModuleGroupByArgs
  _args27.Src = src
  _args27.NumPartitions = numPartitions
  var _result29 IGeneralModuleGroupByResult
  var _meta28 thrift.ResponseMeta
  _meta28, _err = p.Client_().Call(ctx, "groupBy", &_args27, &_result29)
  p.SetLastResponseMeta_(_meta28)
  if _err != nil {
    return
  }
  switch {
  case _result29.Ex!= nil:
    return _result29.Ex
  }

  return nil
}

// Parameters:
//  - Ascending
func (p *IGeneralModuleClient) Sort(ctx context.Context, ascending bool) (_err error) {
  var _args30 IGeneralModuleSortArgs
  _args30.Ascending = ascending
  var _result32 IGeneralModuleSortResult
  var _meta31 thrift.ResponseMeta
  _meta31, _err = p.Client_().Call(ctx, "sort", &_args30, &_result32)
  p.SetLastResponseMeta_(_meta31)
  if _err != nil {
    return
  }
  switch {
  case _result32.Ex!= nil:
    return _result32.Ex
  }

  return nil
}

// Parameters:
//  - Ascending
//  - NumPartitions
func (p *IGeneralModuleClient) Sort2(ctx context.Context, ascending bool, numPartitions int64) (_err error) {
  var _args33 IGeneralModuleSort2Args
  _args33.Ascending = ascending
  _args33.NumPartitions = numPartitions
  var _result35 IGeneralModuleSort2Result
  var _meta34 thrift.ResponseMeta
  _meta34, _err = p.Client_().Call(ctx, "sort2", &_args33, &_result35)
  p.SetLastResponseMeta_(_meta34)
  if _err != nil {
    return
  }
  switch {
  case _result35.Ex!= nil:
    return _result35.Ex
  }

  return nil
}

// Parameters:
//  - Src
//  - Ascending
func (p *IGeneralModuleClient) SortBy(ctx context.Context, src *rpc.ISource, ascending bool) (_err error) {
  var _args36 IGeneralModuleSortByArgs
  _args36.Src = src
  _args36.Ascending = ascending
  var _result38 IGeneralModuleSortByResult
  var _meta37 thrift.ResponseMeta
  _meta37, _err = p.Client_().Call(ctx, "sortBy", &_args36, &_result38)
  p.SetLastResponseMeta_(_meta37)
  if _err != nil {
    return
  }
  switch {
  case _result38.Ex!= nil:
    return _result38.Ex
  }

  return nil
}

// Parameters:
//  - Src
//  - Ascending
//  - NumPartitions
func (p *IGeneralModuleClient) SortBy3(ctx context.Context, src *rpc.ISource, ascending bool, numPartitions int64) (_err error) {
  var _args39 IGeneralModuleSortBy3Args
  _args39.Src = src
  _args39.Ascending = ascending
  _args39.NumPartitions = numPartitions
  var _result41 IGeneralModuleSortBy3Result
  var _meta40 thrift.ResponseMeta
  _meta40, _err = p.Client_().Call(ctx, "sortBy3", &_args39, &_result41)
  p.SetLastResponseMeta_(_meta40)
  if _err != nil {
    return
  }
  switch {
  case _result41.Ex!= nil:
    return _result41.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) FlatMapValues(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args42 IGeneralModuleFlatMapValuesArgs
  _args42.Src = src
  var _result44 IGeneralModuleFlatMapValuesResult
  var _meta43 thrift.ResponseMeta
  _meta43, _err = p.Client_().Call(ctx, "flatMapValues", &_args42, &_result44)
  p.SetLastResponseMeta_(_meta43)
  if _err != nil {
    return
  }
  switch {
  case _result44.Ex!= nil:
    return _result44.Ex
  }

  return nil
}

// Parameters:
//  - Src
func (p *IGeneralModuleClient) MapValues(ctx context.Context, src *rpc.ISource) (_err error) {
  var _args45 IGeneralModuleMapValuesArgs
  _args45.Src = src
  var _result47 IGeneralModuleMapValuesResult
  var _meta46 thrift.ResponseMeta
  _meta46, _err = p.Client_().Call(ctx, "mapValues", &_args45, &_result47)
  p.SetLastResponseMeta_(_meta46)
  if _err != nil {
    return
  }
  switch {
  case _result47.Ex!= nil:
    return _result47.Ex
  }

  return nil
}

// Parameters:
//  - NumPartitions
func (p *IGeneralModuleClient) GroupByKey(ctx context.Context, numPartitions int64) (_err error) {
  var _args48 IGeneralModuleGroupByKeyArgs
  _args48.NumPartitions = numPartitions
  var _result50 IGeneralModuleGroupByKeyResult
  var _meta49 thrift.ResponseMeta
  _meta49, _err = p.Client_().Call(ctx, "groupByKey", &_args48, &_result50)
  p.SetLastResponseMeta_(_meta49)
  if _err != nil {
    return
  }
  switch {
  case _result50.Ex!= nil:
    return _result50.Ex
  }

  return nil
}

// Parameters:
//  - NumPartitions
//  - Src
func (p *IGeneralModuleClient) GroupByKey2(ctx context.Context, numPartitions int64, src *rpc.ISource) (_err error) {
  var _args51 IGeneralModuleGroupByKey2Args
  _args51.NumPartitions = numPartitions
  _args51.Src = src
  var _result53 IGeneralModuleGroupByKey2Result
  var _meta52 thrift.ResponseMeta
  _meta52, _err = p.Client_().Call(ctx, "groupByKey2", &_args51, &_result53)
  p.SetLastResponseMeta_(_meta52)
  if _err != nil {
    return
  }
  switch {
  case _result53.Ex!= nil:
    return _result53.Ex
  }

  return nil
}

// Parameters:
//  - Src
//  - NumPartitions
//  - LocalReduce
func (p *IGeneralModuleClient) ReduceByKey(ctx context.Context, src *rpc.ISource, numPartitions int64, localReduce bool) (_err error) {
  var _args54 IGeneralModuleReduceByKeyArgs
  _args54.Src = src
  _args54.NumPartitions = numPartitions
  _args54.LocalReduce = localReduce
  var _result56 IGeneralModuleReduceByKeyResult
  var _meta55 thrift.ResponseMeta
  _meta55, _err = p.Client_().Call(ctx, "reduceByKey", &_args54, &_result56)
  p.SetLastResponseMeta_(_meta55)
  if _err != nil {
    return
  }
  switch {
  case _result56.Ex!= nil:
    return _result56.Ex
  }

  return nil
}

// Parameters:
//  - Zero
//  - SeqOp
//  - NumPartitions
func (p *IGeneralModuleClient) AggregateByKey(ctx context.Context, zero *rpc.ISource, seqOp *rpc.ISource, numPartitions int64) (_err error) {
  var _args57 IGeneralModuleAggregateByKeyArgs
  _args57.Zero = zero
  _args57.SeqOp = seqOp
  _args57.NumPartitions = numPartitions
  var _result59 IGeneralModuleAggregateByKeyResult
  var _meta58 thrift.ResponseMeta
  _meta58, _err = p.Client_().Call(ctx, "aggregateByKey", &_args57, &_result59)
  p.SetLastResponseMeta_(_meta58)
  if _err != nil {
    return
  }
  switch {
  case _result59.Ex!= nil:
    return _result59.Ex
  }

  return nil
}

// Parameters:
//  - Zero
//  - SeqOp
//  - CombOp
//  - NumPartitions
func (p *IGeneralModuleClient) AggregateByKey4(ctx context.Context, zero *rpc.ISource, seqOp *rpc.ISource, combOp *rpc.ISource, numPartitions int64) (_err error) {
  var _args60 IGeneralModuleAggregateByKey4Args
  _args60.Zero = zero
  _args60.SeqOp = seqOp
  _args60.CombOp = combOp
  _args60.NumPartitions = numPartitions
  var _result62 IGeneralModuleAggregateByKey4Result
  var _meta61 thrift.ResponseMeta
  _meta61, _err = p.Client_().Call(ctx, "aggregateByKey4", &_args60, &_result62)
  p.SetLastResponseMeta_(_meta61)
  if _err != nil {
    return
  }
  switch {
  case _result62.Ex!= nil:
    return _result62.Ex
  }

  return nil
}

// Parameters:
//  - Zero
//  - Src
//  - NumPartitions
//  - LocalFold
func (p *IGeneralModuleClient) FoldByKey(ctx context.Context, zero *rpc.ISource, src *rpc.ISource, numPartitions int64, localFold bool) (_err error) {
  var _args63 IGeneralModuleFoldByKeyArgs
  _args63.Zero = zero
  _args63.Src = src
  _args63.NumPartitions = numPartitions
  _args63.LocalFold = localFold
  var _result65 IGeneralModuleFoldByKeyResult
  var _meta64 thrift.ResponseMeta
  _meta64, _err = p.Client_().Call(ctx, "foldByKey", &_args63, &_result65)
  p.SetLastResponseMeta_(_meta64)
  if _err != nil {
    return
  }
  switch {
  case _result65.Ex!= nil:
    return _result65.Ex
  }

  return nil
}

// Parameters:
//  - Ascending
func (p *IGeneralModuleClient) SortByKey(ctx context.Context, ascending bool) (_err error) {
  var _args66 IGeneralModuleSortByKeyArgs
  _args66.Ascending = ascending
  var _result68 IGeneralModuleSortByKeyResult
  var _meta67 thrift.ResponseMeta
  _meta67, _err = p.Client_().Call(ctx, "sortByKey", &_args66, &_result68)
  p.SetLastResponseMeta_(_meta67)
  if _err != nil {
    return
  }
  switch {
  case _result68.Ex!= nil:
    return _result68.Ex
  }

  return nil
}

// Parameters:
//  - Ascending
//  - NumPartitions
func (p *IGeneralModuleClient) SortByKey2a(ctx context.Context, ascending bool, numPartitions int64) (_err error) {
  var _args69 IGeneralModuleSortByKey2aArgs
  _args69.Ascending = ascending
  _args69.NumPartitions = numPartitions
  var _result71 IGeneralModuleSortByKey2aResult
  var _meta70 thrift.ResponseMeta
  _meta70, _err = p.Client_().Call(ctx, "sortByKey2a", &_args69, &_result71)
  p.SetLastResponseMeta_(_meta70)
  if _err != nil {
    return
  }
  switch {
  case _result71.Ex!= nil:
    return _result71.Ex
  }

  return nil
}

// Parameters:
//  - Src
//  - Ascending
func (p *IGeneralModuleClient) SortByKey2b(ctx context.Context, src *rpc.ISource, ascending bool) (_err error) {
  var _args72 IGeneralModuleSortByKey2bArgs
  _args72.Src = src
  _args72.Ascending = ascending
  var _result74 IGeneralModuleSortByKey2bResult
  var _meta73 thrift.ResponseMeta
  _meta73, _err = p.Client_().Call(ctx, "sortByKey2b", &_args72, &_result74)
  p.SetLastResponseMeta_(_meta73)
  if _err != nil {
    return
  }
  switch {
  case _result74.Ex!= nil:
    return _result74.Ex
  }

  return nil
}

// Parameters:
//  - Src
//  - Ascending
//  - NumPartitions
func (p *IGeneralModuleClient) SortByKey3(ctx context.Context, src *rpc.ISource, ascending bool, numPartitions int64) (_err error) {
  var _args75 IGeneralModuleSortByKey3Args
  _args75.Src = src
  _args75.Ascending = ascending
  _args75.NumPartitions = numPartitions
  var _result77 IGeneralModuleSortByKey3Result
  var _meta76 thrift.ResponseMeta
  _meta76, _err = p.Client_().Call(ctx, "sortByKey3", &_args75, &_result77)
  p.SetLastResponseMeta_(_meta76)
  if _err != nil {
    return
  }
  switch {
  case _result77.Ex!= nil:
    return _result77.Ex
  }

  return nil
}

type IGeneralModuleProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler IGeneralModule
}

func (p *IGeneralModuleProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *IGeneralModuleProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *IGeneralModuleProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewIGeneralModuleProcessor(handler IGeneralModule) *IGeneralModuleProcessor {

  self78 := &IGeneralModuleProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self78.processorMap["executeTo"] = &iGeneralModuleProcessorExecuteTo{handler:handler}
  self78.processorMap["map_"] = &iGeneralModuleProcessorMap_{handler:handler}
  self78.processorMap["filter"] = &iGeneralModuleProcessorFilter{handler:handler}
  self78.processorMap["flatmap"] = &iGeneralModuleProcessorFlatmap{handler:handler}
  self78.processorMap["keyBy"] = &iGeneralModuleProcessorKeyBy{handler:handler}
  self78.processorMap["mapPartitions"] = &iGeneralModuleProcessorMapPartitions{handler:handler}
  self78.processorMap["mapPartitionsWithIndex"] = &iGeneralModuleProcessorMapPartitionsWithIndex{handler:handler}
  self78.processorMap["mapExecutor"] = &iGeneralModuleProcessorMapExecutor{handler:handler}
  self78.processorMap["mapExecutorTo"] = &iGeneralModuleProcessorMapExecutorTo{handler:handler}
  self78.processorMap["groupBy"] = &iGeneralModuleProcessorGroupBy{handler:handler}
  self78.processorMap["sort"] = &iGeneralModuleProcessorSort{handler:handler}
  self78.processorMap["sort2"] = &iGeneralModuleProcessorSort2{handler:handler}
  self78.processorMap["sortBy"] = &iGeneralModuleProcessorSortBy{handler:handler}
  self78.processorMap["sortBy3"] = &iGeneralModuleProcessorSortBy3{handler:handler}
  self78.processorMap["flatMapValues"] = &iGeneralModuleProcessorFlatMapValues{handler:handler}
  self78.processorMap["mapValues"] = &iGeneralModuleProcessorMapValues{handler:handler}
  self78.processorMap["groupByKey"] = &iGeneralModuleProcessorGroupByKey{handler:handler}
  self78.processorMap["groupByKey2"] = &iGeneralModuleProcessorGroupByKey2{handler:handler}
  self78.processorMap["reduceByKey"] = &iGeneralModuleProcessorReduceByKey{handler:handler}
  self78.processorMap["aggregateByKey"] = &iGeneralModuleProcessorAggregateByKey{handler:handler}
  self78.processorMap["aggregateByKey4"] = &iGeneralModuleProcessorAggregateByKey4{handler:handler}
  self78.processorMap["foldByKey"] = &iGeneralModuleProcessorFoldByKey{handler:handler}
  self78.processorMap["sortByKey"] = &iGeneralModuleProcessorSortByKey{handler:handler}
  self78.processorMap["sortByKey2a"] = &iGeneralModuleProcessorSortByKey2a{handler:handler}
  self78.processorMap["sortByKey2b"] = &iGeneralModuleProcessorSortByKey2b{handler:handler}
  self78.processorMap["sortByKey3"] = &iGeneralModuleProcessorSortByKey3{handler:handler}
return self78
}

func (p *IGeneralModuleProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x79 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x79.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x79

}

type iGeneralModuleProcessorExecuteTo struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorExecuteTo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleExecuteToArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "executeTo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleExecuteToResult{}
  if err2 = p.handler.ExecuteTo(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing executeTo: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "executeTo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "executeTo", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorMap_ struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorMap_) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleMap_Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "map_", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleMap_Result{}
  if err2 = p.handler.Map_(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing map_: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "map_", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "map_", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorFilter struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorFilter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleFilterArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "filter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleFilterResult{}
  if err2 = p.handler.Filter(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing filter: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "filter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "filter", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorFlatmap struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorFlatmap) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleFlatmapArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "flatmap", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleFlatmapResult{}
  if err2 = p.handler.Flatmap(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing flatmap: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "flatmap", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "flatmap", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorKeyBy struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorKeyBy) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleKeyByArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "keyBy", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleKeyByResult{}
  if err2 = p.handler.KeyBy(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing keyBy: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "keyBy", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "keyBy", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorMapPartitions struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorMapPartitions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleMapPartitionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mapPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleMapPartitionsResult{}
  if err2 = p.handler.MapPartitions(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapPartitions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "mapPartitions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "mapPartitions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorMapPartitionsWithIndex struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorMapPartitionsWithIndex) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleMapPartitionsWithIndexArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mapPartitionsWithIndex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleMapPartitionsWithIndexResult{}
  if err2 = p.handler.MapPartitionsWithIndex(ctx, args.Src, args.PreservesPartitioning); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapPartitionsWithIndex: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "mapPartitionsWithIndex", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "mapPartitionsWithIndex", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorMapExecutor struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorMapExecutor) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleMapExecutorArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mapExecutor", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleMapExecutorResult{}
  if err2 = p.handler.MapExecutor(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapExecutor: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "mapExecutor", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "mapExecutor", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorMapExecutorTo struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorMapExecutorTo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleMapExecutorToArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mapExecutorTo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleMapExecutorToResult{}
  if err2 = p.handler.MapExecutorTo(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapExecutorTo: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "mapExecutorTo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "mapExecutorTo", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorGroupBy struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorGroupBy) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleGroupByArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "groupBy", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleGroupByResult{}
  if err2 = p.handler.GroupBy(ctx, args.Src, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing groupBy: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "groupBy", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "groupBy", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSort struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSort) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSortArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sort", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSortResult{}
  if err2 = p.handler.Sort(ctx, args.Ascending); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sort: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sort", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sort", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSort2 struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSort2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSort2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sort2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSort2Result{}
  if err2 = p.handler.Sort2(ctx, args.Ascending, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sort2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sort2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sort2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSortBy struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSortBy) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSortByArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sortBy", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSortByResult{}
  if err2 = p.handler.SortBy(ctx, args.Src, args.Ascending); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sortBy: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sortBy", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sortBy", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSortBy3 struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSortBy3) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSortBy3Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sortBy3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSortBy3Result{}
  if err2 = p.handler.SortBy3(ctx, args.Src, args.Ascending, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sortBy3: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sortBy3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sortBy3", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorFlatMapValues struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorFlatMapValues) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleFlatMapValuesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "flatMapValues", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleFlatMapValuesResult{}
  if err2 = p.handler.FlatMapValues(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing flatMapValues: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "flatMapValues", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "flatMapValues", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorMapValues struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorMapValues) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleMapValuesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mapValues", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleMapValuesResult{}
  if err2 = p.handler.MapValues(ctx, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapValues: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "mapValues", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "mapValues", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorGroupByKey struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorGroupByKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleGroupByKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "groupByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleGroupByKeyResult{}
  if err2 = p.handler.GroupByKey(ctx, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing groupByKey: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "groupByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "groupByKey", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorGroupByKey2 struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorGroupByKey2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleGroupByKey2Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "groupByKey2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleGroupByKey2Result{}
  if err2 = p.handler.GroupByKey2(ctx, args.NumPartitions, args.Src); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing groupByKey2: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "groupByKey2", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "groupByKey2", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorReduceByKey struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorReduceByKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleReduceByKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "reduceByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleReduceByKeyResult{}
  if err2 = p.handler.ReduceByKey(ctx, args.Src, args.NumPartitions, args.LocalReduce); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing reduceByKey: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "reduceByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "reduceByKey", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorAggregateByKey struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorAggregateByKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleAggregateByKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "aggregateByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleAggregateByKeyResult{}
  if err2 = p.handler.AggregateByKey(ctx, args.Zero, args.SeqOp, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aggregateByKey: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "aggregateByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "aggregateByKey", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorAggregateByKey4 struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorAggregateByKey4) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleAggregateByKey4Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "aggregateByKey4", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleAggregateByKey4Result{}
  if err2 = p.handler.AggregateByKey4(ctx, args.Zero, args.SeqOp, args.CombOp, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aggregateByKey4: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "aggregateByKey4", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "aggregateByKey4", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorFoldByKey struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorFoldByKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleFoldByKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "foldByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleFoldByKeyResult{}
  if err2 = p.handler.FoldByKey(ctx, args.Zero, args.Src, args.NumPartitions, args.LocalFold); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing foldByKey: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "foldByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "foldByKey", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSortByKey struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSortByKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSortByKeyArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSortByKeyResult{}
  if err2 = p.handler.SortByKey(ctx, args.Ascending); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sortByKey: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sortByKey", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSortByKey2a struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSortByKey2a) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSortByKey2aArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey2a", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSortByKey2aResult{}
  if err2 = p.handler.SortByKey2a(ctx, args.Ascending, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sortByKey2a: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey2a", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sortByKey2a", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSortByKey2b struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSortByKey2b) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSortByKey2bArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey2b", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSortByKey2bResult{}
  if err2 = p.handler.SortByKey2b(ctx, args.Src, args.Ascending); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sortByKey2b: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey2b", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sortByKey2b", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type iGeneralModuleProcessorSortByKey3 struct {
  handler IGeneralModule
}

func (p *iGeneralModuleProcessorSortByKey3) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := IGeneralModuleSortByKey3Args{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := IGeneralModuleSortByKey3Result{}
  if err2 = p.handler.SortByKey3(ctx, args.Src, args.Ascending, args.NumPartitions); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *rpc.IExecutorException:
  result.Ex = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sortByKey3: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "sortByKey3", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "sortByKey3", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Src
type IGeneralModuleExecuteToArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleExecuteToArgs() *IGeneralModuleExecuteToArgs {
  return &IGeneralModuleExecuteToArgs{}
}

var IGeneralModuleExecuteToArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleExecuteToArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleExecuteToArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleExecuteToArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleExecuteToArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleExecuteToArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleExecuteToArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "executeTo_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleExecuteToArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleExecuteToArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleExecuteToArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleExecuteToResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleExecuteToResult() *IGeneralModuleExecuteToResult {
  return &IGeneralModuleExecuteToResult{}
}

var IGeneralModuleExecuteToResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleExecuteToResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleExecuteToResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleExecuteToResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleExecuteToResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleExecuteToResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleExecuteToResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "executeTo_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleExecuteToResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleExecuteToResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleExecuteToResult(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleMap_Args struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleMap_Args() *IGeneralModuleMap_Args {
  return &IGeneralModuleMap_Args{}
}

var IGeneralModuleMap_Args_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleMap_Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleMap_Args_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleMap_Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleMap_Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMap_Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleMap_Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "map__args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMap_Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleMap_Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMap_Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleMap_Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleMap_Result() *IGeneralModuleMap_Result {
  return &IGeneralModuleMap_Result{}
}

var IGeneralModuleMap_Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleMap_Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleMap_Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleMap_Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleMap_Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMap_Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleMap_Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "map__result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMap_Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleMap_Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMap_Result(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleFilterArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleFilterArgs() *IGeneralModuleFilterArgs {
  return &IGeneralModuleFilterArgs{}
}

var IGeneralModuleFilterArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleFilterArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleFilterArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleFilterArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleFilterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFilterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleFilterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "filter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFilterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleFilterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFilterArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleFilterResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleFilterResult() *IGeneralModuleFilterResult {
  return &IGeneralModuleFilterResult{}
}

var IGeneralModuleFilterResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleFilterResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleFilterResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleFilterResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleFilterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFilterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleFilterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "filter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFilterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleFilterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFilterResult(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleFlatmapArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleFlatmapArgs() *IGeneralModuleFlatmapArgs {
  return &IGeneralModuleFlatmapArgs{}
}

var IGeneralModuleFlatmapArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleFlatmapArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleFlatmapArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleFlatmapArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleFlatmapArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFlatmapArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleFlatmapArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "flatmap_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFlatmapArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleFlatmapArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFlatmapArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleFlatmapResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleFlatmapResult() *IGeneralModuleFlatmapResult {
  return &IGeneralModuleFlatmapResult{}
}

var IGeneralModuleFlatmapResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleFlatmapResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleFlatmapResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleFlatmapResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleFlatmapResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFlatmapResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleFlatmapResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "flatmap_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFlatmapResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleFlatmapResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFlatmapResult(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleKeyByArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleKeyByArgs() *IGeneralModuleKeyByArgs {
  return &IGeneralModuleKeyByArgs{}
}

var IGeneralModuleKeyByArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleKeyByArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleKeyByArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleKeyByArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleKeyByArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleKeyByArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleKeyByArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "keyBy_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleKeyByArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleKeyByArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleKeyByArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleKeyByResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleKeyByResult() *IGeneralModuleKeyByResult {
  return &IGeneralModuleKeyByResult{}
}

var IGeneralModuleKeyByResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleKeyByResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleKeyByResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleKeyByResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleKeyByResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleKeyByResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleKeyByResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "keyBy_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleKeyByResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleKeyByResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleKeyByResult(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleMapPartitionsArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleMapPartitionsArgs() *IGeneralModuleMapPartitionsArgs {
  return &IGeneralModuleMapPartitionsArgs{}
}

var IGeneralModuleMapPartitionsArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleMapPartitionsArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleMapPartitionsArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleMapPartitionsArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleMapPartitionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapPartitions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapPartitionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleMapPartitionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapPartitionsArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleMapPartitionsResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleMapPartitionsResult() *IGeneralModuleMapPartitionsResult {
  return &IGeneralModuleMapPartitionsResult{}
}

var IGeneralModuleMapPartitionsResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleMapPartitionsResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleMapPartitionsResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleMapPartitionsResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleMapPartitionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapPartitions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapPartitionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleMapPartitionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapPartitionsResult(%+v)", *p)
}

// Attributes:
//  - Src
//  - PreservesPartitioning
type IGeneralModuleMapPartitionsWithIndexArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
  PreservesPartitioning bool `thrift:"preservesPartitioning,2" db:"preservesPartitioning" json:"preservesPartitioning"`
}

func NewIGeneralModuleMapPartitionsWithIndexArgs() *IGeneralModuleMapPartitionsWithIndexArgs {
  return &IGeneralModuleMapPartitionsWithIndexArgs{}
}

var IGeneralModuleMapPartitionsWithIndexArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleMapPartitionsWithIndexArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleMapPartitionsWithIndexArgs_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs) GetPreservesPartitioning() bool {
  return p.PreservesPartitioning
}
func (p *IGeneralModuleMapPartitionsWithIndexArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.PreservesPartitioning = v
}
  return nil
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapPartitionsWithIndex_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "preservesPartitioning", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:preservesPartitioning: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.PreservesPartitioning)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.preservesPartitioning (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:preservesPartitioning: ", p), err) }
  return err
}

func (p *IGeneralModuleMapPartitionsWithIndexArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapPartitionsWithIndexArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleMapPartitionsWithIndexResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleMapPartitionsWithIndexResult() *IGeneralModuleMapPartitionsWithIndexResult {
  return &IGeneralModuleMapPartitionsWithIndexResult{}
}

var IGeneralModuleMapPartitionsWithIndexResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleMapPartitionsWithIndexResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleMapPartitionsWithIndexResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleMapPartitionsWithIndexResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleMapPartitionsWithIndexResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsWithIndexResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleMapPartitionsWithIndexResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapPartitionsWithIndex_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapPartitionsWithIndexResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleMapPartitionsWithIndexResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapPartitionsWithIndexResult(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleMapExecutorArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleMapExecutorArgs() *IGeneralModuleMapExecutorArgs {
  return &IGeneralModuleMapExecutorArgs{}
}

var IGeneralModuleMapExecutorArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleMapExecutorArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleMapExecutorArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleMapExecutorArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleMapExecutorArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapExecutor_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapExecutorArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleMapExecutorArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapExecutorArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleMapExecutorResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleMapExecutorResult() *IGeneralModuleMapExecutorResult {
  return &IGeneralModuleMapExecutorResult{}
}

var IGeneralModuleMapExecutorResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleMapExecutorResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleMapExecutorResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleMapExecutorResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleMapExecutorResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapExecutor_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapExecutorResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleMapExecutorResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapExecutorResult(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleMapExecutorToArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleMapExecutorToArgs() *IGeneralModuleMapExecutorToArgs {
  return &IGeneralModuleMapExecutorToArgs{}
}

var IGeneralModuleMapExecutorToArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleMapExecutorToArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleMapExecutorToArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleMapExecutorToArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleMapExecutorToArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorToArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorToArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapExecutorTo_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapExecutorToArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleMapExecutorToArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapExecutorToArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleMapExecutorToResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleMapExecutorToResult() *IGeneralModuleMapExecutorToResult {
  return &IGeneralModuleMapExecutorToResult{}
}

var IGeneralModuleMapExecutorToResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleMapExecutorToResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleMapExecutorToResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleMapExecutorToResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleMapExecutorToResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorToResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleMapExecutorToResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapExecutorTo_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapExecutorToResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleMapExecutorToResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapExecutorToResult(%+v)", *p)
}

// Attributes:
//  - Src
//  - NumPartitions
type IGeneralModuleGroupByArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
  NumPartitions int64 `thrift:"numPartitions,2" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleGroupByArgs() *IGeneralModuleGroupByArgs {
  return &IGeneralModuleGroupByArgs{}
}

var IGeneralModuleGroupByArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleGroupByArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleGroupByArgs_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleGroupByArgs) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleGroupByArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleGroupByArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleGroupByArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "groupBy_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleGroupByArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleGroupByArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleGroupByArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleGroupByArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleGroupByResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleGroupByResult() *IGeneralModuleGroupByResult {
  return &IGeneralModuleGroupByResult{}
}

var IGeneralModuleGroupByResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleGroupByResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleGroupByResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleGroupByResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleGroupByResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "groupBy_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleGroupByResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleGroupByResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleGroupByResult(%+v)", *p)
}

// Attributes:
//  - Ascending
type IGeneralModuleSortArgs struct {
  Ascending bool `thrift:"ascending,1" db:"ascending" json:"ascending"`
}

func NewIGeneralModuleSortArgs() *IGeneralModuleSortArgs {
  return &IGeneralModuleSortArgs{}
}


func (p *IGeneralModuleSortArgs) GetAscending() bool {
  return p.Ascending
}
func (p *IGeneralModuleSortArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSortArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sort_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSortArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSortResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSortResult() *IGeneralModuleSortResult {
  return &IGeneralModuleSortResult{}
}

var IGeneralModuleSortResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSortResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSortResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSortResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSortResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSortResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sort_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSortResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortResult(%+v)", *p)
}

// Attributes:
//  - Ascending
//  - NumPartitions
type IGeneralModuleSort2Args struct {
  Ascending bool `thrift:"ascending,1" db:"ascending" json:"ascending"`
  NumPartitions int64 `thrift:"numPartitions,2" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleSort2Args() *IGeneralModuleSort2Args {
  return &IGeneralModuleSort2Args{}
}


func (p *IGeneralModuleSort2Args) GetAscending() bool {
  return p.Ascending
}

func (p *IGeneralModuleSort2Args) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleSort2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSort2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSort2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleSort2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sort2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSort2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSort2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleSort2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSort2Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSort2Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSort2Result() *IGeneralModuleSort2Result {
  return &IGeneralModuleSort2Result{}
}

var IGeneralModuleSort2Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSort2Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSort2Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSort2Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSort2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSort2Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSort2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sort2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSort2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSort2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSort2Result(%+v)", *p)
}

// Attributes:
//  - Src
//  - Ascending
type IGeneralModuleSortByArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
  Ascending bool `thrift:"ascending,2" db:"ascending" json:"ascending"`
}

func NewIGeneralModuleSortByArgs() *IGeneralModuleSortByArgs {
  return &IGeneralModuleSortByArgs{}
}

var IGeneralModuleSortByArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleSortByArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleSortByArgs_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleSortByArgs) GetAscending() bool {
  return p.Ascending
}
func (p *IGeneralModuleSortByArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleSortByArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleSortByArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSortByArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortBy_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSortByResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSortByResult() *IGeneralModuleSortByResult {
  return &IGeneralModuleSortByResult{}
}

var IGeneralModuleSortByResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSortByResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSortByResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSortByResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSortByResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSortByResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortBy_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSortByResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByResult(%+v)", *p)
}

// Attributes:
//  - Src
//  - Ascending
//  - NumPartitions
type IGeneralModuleSortBy3Args struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
  Ascending bool `thrift:"ascending,2" db:"ascending" json:"ascending"`
  NumPartitions int64 `thrift:"numPartitions,3" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleSortBy3Args() *IGeneralModuleSortBy3Args {
  return &IGeneralModuleSortBy3Args{}
}

var IGeneralModuleSortBy3Args_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleSortBy3Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleSortBy3Args_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleSortBy3Args) GetAscending() bool {
  return p.Ascending
}

func (p *IGeneralModuleSortBy3Args) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleSortBy3Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleSortBy3Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortBy3Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleSortBy3Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSortBy3Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleSortBy3Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortBy3_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortBy3Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleSortBy3Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSortBy3Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleSortBy3Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortBy3Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSortBy3Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSortBy3Result() *IGeneralModuleSortBy3Result {
  return &IGeneralModuleSortBy3Result{}
}

var IGeneralModuleSortBy3Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSortBy3Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSortBy3Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSortBy3Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSortBy3Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortBy3Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSortBy3Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortBy3_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortBy3Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSortBy3Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortBy3Result(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleFlatMapValuesArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleFlatMapValuesArgs() *IGeneralModuleFlatMapValuesArgs {
  return &IGeneralModuleFlatMapValuesArgs{}
}

var IGeneralModuleFlatMapValuesArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleFlatMapValuesArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleFlatMapValuesArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleFlatMapValuesArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleFlatMapValuesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFlatMapValuesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleFlatMapValuesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "flatMapValues_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFlatMapValuesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleFlatMapValuesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFlatMapValuesArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleFlatMapValuesResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleFlatMapValuesResult() *IGeneralModuleFlatMapValuesResult {
  return &IGeneralModuleFlatMapValuesResult{}
}

var IGeneralModuleFlatMapValuesResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleFlatMapValuesResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleFlatMapValuesResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleFlatMapValuesResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleFlatMapValuesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFlatMapValuesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleFlatMapValuesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "flatMapValues_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFlatMapValuesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleFlatMapValuesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFlatMapValuesResult(%+v)", *p)
}

// Attributes:
//  - Src
type IGeneralModuleMapValuesArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
}

func NewIGeneralModuleMapValuesArgs() *IGeneralModuleMapValuesArgs {
  return &IGeneralModuleMapValuesArgs{}
}

var IGeneralModuleMapValuesArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleMapValuesArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleMapValuesArgs_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleMapValuesArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleMapValuesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapValuesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleMapValuesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapValues_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapValuesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleMapValuesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapValuesArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleMapValuesResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleMapValuesResult() *IGeneralModuleMapValuesResult {
  return &IGeneralModuleMapValuesResult{}
}

var IGeneralModuleMapValuesResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleMapValuesResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleMapValuesResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleMapValuesResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleMapValuesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleMapValuesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleMapValuesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mapValues_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleMapValuesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleMapValuesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleMapValuesResult(%+v)", *p)
}

// Attributes:
//  - NumPartitions
type IGeneralModuleGroupByKeyArgs struct {
  NumPartitions int64 `thrift:"numPartitions,1" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleGroupByKeyArgs() *IGeneralModuleGroupByKeyArgs {
  return &IGeneralModuleGroupByKeyArgs{}
}


func (p *IGeneralModuleGroupByKeyArgs) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleGroupByKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleGroupByKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "groupByKey_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleGroupByKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleGroupByKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleGroupByKeyArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleGroupByKeyResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleGroupByKeyResult() *IGeneralModuleGroupByKeyResult {
  return &IGeneralModuleGroupByKeyResult{}
}

var IGeneralModuleGroupByKeyResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleGroupByKeyResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleGroupByKeyResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleGroupByKeyResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleGroupByKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByKeyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "groupByKey_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleGroupByKeyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleGroupByKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleGroupByKeyResult(%+v)", *p)
}

// Attributes:
//  - NumPartitions
//  - Src
type IGeneralModuleGroupByKey2Args struct {
  NumPartitions int64 `thrift:"numPartitions,1" db:"numPartitions" json:"numPartitions"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
}

func NewIGeneralModuleGroupByKey2Args() *IGeneralModuleGroupByKey2Args {
  return &IGeneralModuleGroupByKey2Args{}
}


func (p *IGeneralModuleGroupByKey2Args) GetNumPartitions() int64 {
  return p.NumPartitions
}
var IGeneralModuleGroupByKey2Args_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleGroupByKey2Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleGroupByKey2Args_Src_DEFAULT
  }
return p.Src
}
func (p *IGeneralModuleGroupByKey2Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleGroupByKey2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByKey2Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleGroupByKey2Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByKey2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "groupByKey2_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleGroupByKey2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleGroupByKey2Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *IGeneralModuleGroupByKey2Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleGroupByKey2Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleGroupByKey2Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleGroupByKey2Result() *IGeneralModuleGroupByKey2Result {
  return &IGeneralModuleGroupByKey2Result{}
}

var IGeneralModuleGroupByKey2Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleGroupByKey2Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleGroupByKey2Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleGroupByKey2Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleGroupByKey2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByKey2Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleGroupByKey2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "groupByKey2_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleGroupByKey2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleGroupByKey2Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleGroupByKey2Result(%+v)", *p)
}

// Attributes:
//  - Src
//  - NumPartitions
//  - LocalReduce
type IGeneralModuleReduceByKeyArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
  NumPartitions int64 `thrift:"numPartitions,2" db:"numPartitions" json:"numPartitions"`
  LocalReduce bool `thrift:"localReduce,3" db:"localReduce" json:"localReduce"`
}

func NewIGeneralModuleReduceByKeyArgs() *IGeneralModuleReduceByKeyArgs {
  return &IGeneralModuleReduceByKeyArgs{}
}

var IGeneralModuleReduceByKeyArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleReduceByKeyArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleReduceByKeyArgs_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleReduceByKeyArgs) GetNumPartitions() int64 {
  return p.NumPartitions
}

func (p *IGeneralModuleReduceByKeyArgs) GetLocalReduce() bool {
  return p.LocalReduce
}
func (p *IGeneralModuleReduceByKeyArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleReduceByKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleReduceByKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleReduceByKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleReduceByKeyArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.LocalReduce = v
}
  return nil
}

func (p *IGeneralModuleReduceByKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "reduceByKey_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleReduceByKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleReduceByKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleReduceByKeyArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "localReduce", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:localReduce: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.LocalReduce)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.localReduce (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:localReduce: ", p), err) }
  return err
}

func (p *IGeneralModuleReduceByKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleReduceByKeyArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleReduceByKeyResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleReduceByKeyResult() *IGeneralModuleReduceByKeyResult {
  return &IGeneralModuleReduceByKeyResult{}
}

var IGeneralModuleReduceByKeyResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleReduceByKeyResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleReduceByKeyResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleReduceByKeyResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleReduceByKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleReduceByKeyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleReduceByKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "reduceByKey_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleReduceByKeyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleReduceByKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleReduceByKeyResult(%+v)", *p)
}

// Attributes:
//  - Zero
//  - SeqOp
//  - NumPartitions
type IGeneralModuleAggregateByKeyArgs struct {
  Zero *rpc.ISource `thrift:"zero,1" db:"zero" json:"zero"`
  SeqOp *rpc.ISource `thrift:"seqOp,2" db:"seqOp" json:"seqOp"`
  NumPartitions int64 `thrift:"numPartitions,3" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleAggregateByKeyArgs() *IGeneralModuleAggregateByKeyArgs {
  return &IGeneralModuleAggregateByKeyArgs{}
}

var IGeneralModuleAggregateByKeyArgs_Zero_DEFAULT *rpc.ISource
func (p *IGeneralModuleAggregateByKeyArgs) GetZero() *rpc.ISource {
  if !p.IsSetZero() {
    return IGeneralModuleAggregateByKeyArgs_Zero_DEFAULT
  }
return p.Zero
}
var IGeneralModuleAggregateByKeyArgs_SeqOp_DEFAULT *rpc.ISource
func (p *IGeneralModuleAggregateByKeyArgs) GetSeqOp() *rpc.ISource {
  if !p.IsSetSeqOp() {
    return IGeneralModuleAggregateByKeyArgs_SeqOp_DEFAULT
  }
return p.SeqOp
}

func (p *IGeneralModuleAggregateByKeyArgs) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleAggregateByKeyArgs) IsSetZero() bool {
  return p.Zero != nil
}

func (p *IGeneralModuleAggregateByKeyArgs) IsSetSeqOp() bool {
  return p.SeqOp != nil
}

func (p *IGeneralModuleAggregateByKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Zero = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Zero.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Zero), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SeqOp = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.SeqOp.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SeqOp), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKeyArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleAggregateByKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aggregateByKey_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleAggregateByKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "zero", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:zero: ", p), err) }
  if err := p.Zero.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Zero), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:zero: ", p), err) }
  return err
}

func (p *IGeneralModuleAggregateByKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "seqOp", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:seqOp: ", p), err) }
  if err := p.SeqOp.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SeqOp), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:seqOp: ", p), err) }
  return err
}

func (p *IGeneralModuleAggregateByKeyArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleAggregateByKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleAggregateByKeyArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleAggregateByKeyResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleAggregateByKeyResult() *IGeneralModuleAggregateByKeyResult {
  return &IGeneralModuleAggregateByKeyResult{}
}

var IGeneralModuleAggregateByKeyResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleAggregateByKeyResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleAggregateByKeyResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleAggregateByKeyResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleAggregateByKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKeyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aggregateByKey_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleAggregateByKeyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleAggregateByKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleAggregateByKeyResult(%+v)", *p)
}

// Attributes:
//  - Zero
//  - SeqOp
//  - CombOp
//  - NumPartitions
type IGeneralModuleAggregateByKey4Args struct {
  Zero *rpc.ISource `thrift:"zero,1" db:"zero" json:"zero"`
  SeqOp *rpc.ISource `thrift:"seqOp,2" db:"seqOp" json:"seqOp"`
  CombOp *rpc.ISource `thrift:"combOp,3" db:"combOp" json:"combOp"`
  NumPartitions int64 `thrift:"numPartitions,4" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleAggregateByKey4Args() *IGeneralModuleAggregateByKey4Args {
  return &IGeneralModuleAggregateByKey4Args{}
}

var IGeneralModuleAggregateByKey4Args_Zero_DEFAULT *rpc.ISource
func (p *IGeneralModuleAggregateByKey4Args) GetZero() *rpc.ISource {
  if !p.IsSetZero() {
    return IGeneralModuleAggregateByKey4Args_Zero_DEFAULT
  }
return p.Zero
}
var IGeneralModuleAggregateByKey4Args_SeqOp_DEFAULT *rpc.ISource
func (p *IGeneralModuleAggregateByKey4Args) GetSeqOp() *rpc.ISource {
  if !p.IsSetSeqOp() {
    return IGeneralModuleAggregateByKey4Args_SeqOp_DEFAULT
  }
return p.SeqOp
}
var IGeneralModuleAggregateByKey4Args_CombOp_DEFAULT *rpc.ISource
func (p *IGeneralModuleAggregateByKey4Args) GetCombOp() *rpc.ISource {
  if !p.IsSetCombOp() {
    return IGeneralModuleAggregateByKey4Args_CombOp_DEFAULT
  }
return p.CombOp
}

func (p *IGeneralModuleAggregateByKey4Args) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleAggregateByKey4Args) IsSetZero() bool {
  return p.Zero != nil
}

func (p *IGeneralModuleAggregateByKey4Args) IsSetSeqOp() bool {
  return p.SeqOp != nil
}

func (p *IGeneralModuleAggregateByKey4Args) IsSetCombOp() bool {
  return p.CombOp != nil
}

func (p *IGeneralModuleAggregateByKey4Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Zero = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Zero.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Zero), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SeqOp = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.SeqOp.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SeqOp), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.CombOp = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.CombOp.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CombOp), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Args)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleAggregateByKey4Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aggregateByKey4_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "zero", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:zero: ", p), err) }
  if err := p.Zero.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Zero), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:zero: ", p), err) }
  return err
}

func (p *IGeneralModuleAggregateByKey4Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "seqOp", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:seqOp: ", p), err) }
  if err := p.SeqOp.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SeqOp), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:seqOp: ", p), err) }
  return err
}

func (p *IGeneralModuleAggregateByKey4Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "combOp", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:combOp: ", p), err) }
  if err := p.CombOp.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CombOp), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:combOp: ", p), err) }
  return err
}

func (p *IGeneralModuleAggregateByKey4Args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleAggregateByKey4Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleAggregateByKey4Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleAggregateByKey4Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleAggregateByKey4Result() *IGeneralModuleAggregateByKey4Result {
  return &IGeneralModuleAggregateByKey4Result{}
}

var IGeneralModuleAggregateByKey4Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleAggregateByKey4Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleAggregateByKey4Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleAggregateByKey4Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleAggregateByKey4Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "aggregateByKey4_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleAggregateByKey4Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleAggregateByKey4Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleAggregateByKey4Result(%+v)", *p)
}

// Attributes:
//  - Zero
//  - Src
//  - NumPartitions
//  - LocalFold
type IGeneralModuleFoldByKeyArgs struct {
  Zero *rpc.ISource `thrift:"zero,1" db:"zero" json:"zero"`
  Src *rpc.ISource `thrift:"src,2" db:"src" json:"src"`
  NumPartitions int64 `thrift:"numPartitions,3" db:"numPartitions" json:"numPartitions"`
  LocalFold bool `thrift:"localFold,4" db:"localFold" json:"localFold"`
}

func NewIGeneralModuleFoldByKeyArgs() *IGeneralModuleFoldByKeyArgs {
  return &IGeneralModuleFoldByKeyArgs{}
}

var IGeneralModuleFoldByKeyArgs_Zero_DEFAULT *rpc.ISource
func (p *IGeneralModuleFoldByKeyArgs) GetZero() *rpc.ISource {
  if !p.IsSetZero() {
    return IGeneralModuleFoldByKeyArgs_Zero_DEFAULT
  }
return p.Zero
}
var IGeneralModuleFoldByKeyArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleFoldByKeyArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleFoldByKeyArgs_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleFoldByKeyArgs) GetNumPartitions() int64 {
  return p.NumPartitions
}

func (p *IGeneralModuleFoldByKeyArgs) GetLocalFold() bool {
  return p.LocalFold
}
func (p *IGeneralModuleFoldByKeyArgs) IsSetZero() bool {
  return p.Zero != nil
}

func (p *IGeneralModuleFoldByKeyArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleFoldByKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFoldByKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Zero = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Zero.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Zero), err)
  }
  return nil
}

func (p *IGeneralModuleFoldByKeyArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleFoldByKeyArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleFoldByKeyArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.LocalFold = v
}
  return nil
}

func (p *IGeneralModuleFoldByKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "foldByKey_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFoldByKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "zero", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:zero: ", p), err) }
  if err := p.Zero.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Zero), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:zero: ", p), err) }
  return err
}

func (p *IGeneralModuleFoldByKeyArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:src: ", p), err) }
  return err
}

func (p *IGeneralModuleFoldByKeyArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleFoldByKeyArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "localFold", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:localFold: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.LocalFold)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.localFold (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:localFold: ", p), err) }
  return err
}

func (p *IGeneralModuleFoldByKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFoldByKeyArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleFoldByKeyResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleFoldByKeyResult() *IGeneralModuleFoldByKeyResult {
  return &IGeneralModuleFoldByKeyResult{}
}

var IGeneralModuleFoldByKeyResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleFoldByKeyResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleFoldByKeyResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleFoldByKeyResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleFoldByKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleFoldByKeyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleFoldByKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "foldByKey_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleFoldByKeyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleFoldByKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleFoldByKeyResult(%+v)", *p)
}

// Attributes:
//  - Ascending
type IGeneralModuleSortByKeyArgs struct {
  Ascending bool `thrift:"ascending,1" db:"ascending" json:"ascending"`
}

func NewIGeneralModuleSortByKeyArgs() *IGeneralModuleSortByKeyArgs {
  return &IGeneralModuleSortByKeyArgs{}
}


func (p *IGeneralModuleSortByKeyArgs) GetAscending() bool {
  return p.Ascending
}
func (p *IGeneralModuleSortByKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSortByKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKeyArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSortByKeyResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSortByKeyResult() *IGeneralModuleSortByKeyResult {
  return &IGeneralModuleSortByKeyResult{}
}

var IGeneralModuleSortByKeyResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSortByKeyResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSortByKeyResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSortByKeyResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSortByKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKeyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKeyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSortByKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKeyResult(%+v)", *p)
}

// Attributes:
//  - Ascending
//  - NumPartitions
type IGeneralModuleSortByKey2aArgs struct {
  Ascending bool `thrift:"ascending,1" db:"ascending" json:"ascending"`
  NumPartitions int64 `thrift:"numPartitions,2" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleSortByKey2aArgs() *IGeneralModuleSortByKey2aArgs {
  return &IGeneralModuleSortByKey2aArgs{}
}


func (p *IGeneralModuleSortByKey2aArgs) GetAscending() bool {
  return p.Ascending
}

func (p *IGeneralModuleSortByKey2aArgs) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleSortByKey2aArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey2aArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSortByKey2aArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleSortByKey2aArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey2a_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKey2aArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKey2aArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKey2aArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKey2aArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSortByKey2aResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSortByKey2aResult() *IGeneralModuleSortByKey2aResult {
  return &IGeneralModuleSortByKey2aResult{}
}

var IGeneralModuleSortByKey2aResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSortByKey2aResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSortByKey2aResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSortByKey2aResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSortByKey2aResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey2aResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey2aResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey2a_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKey2aResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSortByKey2aResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKey2aResult(%+v)", *p)
}

// Attributes:
//  - Src
//  - Ascending
type IGeneralModuleSortByKey2bArgs struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
  Ascending bool `thrift:"ascending,2" db:"ascending" json:"ascending"`
}

func NewIGeneralModuleSortByKey2bArgs() *IGeneralModuleSortByKey2bArgs {
  return &IGeneralModuleSortByKey2bArgs{}
}

var IGeneralModuleSortByKey2bArgs_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleSortByKey2bArgs) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleSortByKey2bArgs_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleSortByKey2bArgs) GetAscending() bool {
  return p.Ascending
}
func (p *IGeneralModuleSortByKey2bArgs) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleSortByKey2bArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey2bArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey2bArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSortByKey2bArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey2b_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKey2bArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKey2bArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKey2bArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKey2bArgs(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSortByKey2bResult struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSortByKey2bResult() *IGeneralModuleSortByKey2bResult {
  return &IGeneralModuleSortByKey2bResult{}
}

var IGeneralModuleSortByKey2bResult_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSortByKey2bResult) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSortByKey2bResult_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSortByKey2bResult) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSortByKey2bResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey2bResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey2bResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey2b_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKey2bResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSortByKey2bResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKey2bResult(%+v)", *p)
}

// Attributes:
//  - Src
//  - Ascending
//  - NumPartitions
type IGeneralModuleSortByKey3Args struct {
  Src *rpc.ISource `thrift:"src,1" db:"src" json:"src"`
  Ascending bool `thrift:"ascending,2" db:"ascending" json:"ascending"`
  NumPartitions int64 `thrift:"numPartitions,3" db:"numPartitions" json:"numPartitions"`
}

func NewIGeneralModuleSortByKey3Args() *IGeneralModuleSortByKey3Args {
  return &IGeneralModuleSortByKey3Args{}
}

var IGeneralModuleSortByKey3Args_Src_DEFAULT *rpc.ISource
func (p *IGeneralModuleSortByKey3Args) GetSrc() *rpc.ISource {
  if !p.IsSetSrc() {
    return IGeneralModuleSortByKey3Args_Src_DEFAULT
  }
return p.Src
}

func (p *IGeneralModuleSortByKey3Args) GetAscending() bool {
  return p.Ascending
}

func (p *IGeneralModuleSortByKey3Args) GetNumPartitions() int64 {
  return p.NumPartitions
}
func (p *IGeneralModuleSortByKey3Args) IsSetSrc() bool {
  return p.Src != nil
}

func (p *IGeneralModuleSortByKey3Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey3Args)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &rpc.ISource{
  Params: map[string][]byte{
  },
}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey3Args)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ascending = v
}
  return nil
}

func (p *IGeneralModuleSortByKey3Args)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NumPartitions = v
}
  return nil
}

func (p *IGeneralModuleSortByKey3Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey3_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKey3Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKey3Args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ascending: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Ascending)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ascending (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ascending: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKey3Args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "numPartitions", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:numPartitions: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.NumPartitions)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.numPartitions (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:numPartitions: ", p), err) }
  return err
}

func (p *IGeneralModuleSortByKey3Args) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKey3Args(%+v)", *p)
}

// Attributes:
//  - Ex
type IGeneralModuleSortByKey3Result struct {
  Ex *rpc.IExecutorException `thrift:"ex,1" db:"ex" json:"ex,omitempty"`
}

func NewIGeneralModuleSortByKey3Result() *IGeneralModuleSortByKey3Result {
  return &IGeneralModuleSortByKey3Result{}
}

var IGeneralModuleSortByKey3Result_Ex_DEFAULT *rpc.IExecutorException
func (p *IGeneralModuleSortByKey3Result) GetEx() *rpc.IExecutorException {
  if !p.IsSetEx() {
    return IGeneralModuleSortByKey3Result_Ex_DEFAULT
  }
return p.Ex
}
func (p *IGeneralModuleSortByKey3Result) IsSetEx() bool {
  return p.Ex != nil
}

func (p *IGeneralModuleSortByKey3Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey3Result)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Ex = &rpc.IExecutorException{}
  if err := p.Ex.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ex), err)
  }
  return nil
}

func (p *IGeneralModuleSortByKey3Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sortByKey3_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *IGeneralModuleSortByKey3Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEx() {
    if err := oprot.WriteFieldBegin(ctx, "ex", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ex: ", p), err) }
    if err := p.Ex.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ex), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ex: ", p), err) }
  }
  return err
}

func (p *IGeneralModuleSortByKey3Result) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("IGeneralModuleSortByKey3Result(%+v)", *p)
}


